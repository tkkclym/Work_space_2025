# 弄清楚对一些常用类型的理解：



很多都是在引擎中经常出现，但是不是特别理解其作用和原理的东西

### Handle句柄：

> 句柄，英文原文handle，是计算机术语中翻译得最烂的词，（几乎）没有之一。

1. 意指通过其可以实现对于某种计算实体的识别或控制即可。
2. 这样说有点抽象，举个例子。door handle 是指门把手，通过门把手可以去控制门，但 door handle 并非 door 本身，只是一个中间媒介。又比如 knife handle 是刀柄，通过刀柄可以使用刀.
3. 用 handle 如何操作真正的资源，是实现的细节。

#### 那句柄的实现原理是什么呢？

好问题，首先想想句柄的类型是什么？

<img src="..\Workiong_File\snpi\局部截取_20250314_111058.png" alt="局部截取_20250314_111058" style="zoom:25%;" />

另一个FStateTreeDataHandle的就不放了，都是struct类型。



这个状态Handle是为了管理状态树中的众多状态.

1. **数据结构定义**

​		状态句柄通常以结构体的形式存在，其核心成员是一个索引（Index）,一般为unit16类型

- 为哈要用索引呢？这个索引作用是指向状态树里的特定状态。把索引类型设定为unit16，是为了在确保足够索引范围内尽可能减少内存。

2. **特殊索引值的使用**

​	表示一些特殊状态，，状态句柄定义了若干特殊的索引常量，如InvalidIndex，SuccessedIndex,FailedIndex和StoppedIndex

3. **索引有效性**

​	得确保索引是不是有效，是不是在有效范围内啊static bool IsValidIndex(const int32 Index)



4.  最重要的来了，句柄得具备状态转换和完成状态管理功能啊.通过ToCompletionStatus 和FromCompletionStatus 可以在状态句柄和EStateTreeRunStatus枚举状态之间进行转换

5. **底层存储与映射**

   句柄嘛，只是方便操作的工具。在引擎底层会维护一个状态数组或者其他数据结构，**状态句柄的索引就是这个数组的下标。**通过索引，句柄可以快速定位到对应的状态对象，这种映射关系使得状态句柄能够更高效地引用状态

6. **内存管理和生命周期**

​	句柄本身是一个轻量级数据结构，不直接管理状态对象的内存。状态对象内存管理由状态数系统负责，当状态对象被创建或者销毁的时候，状态句柄有效性会更新.例如，当一个状态对象被销毁时，对应的状态句柄会被标记为无效（`InvalidIndex`），避免悬空引用。







这个句柄为啥使用struct创建的还有其他类型吗？？

### Context上下文：



这里可以举一个状态数执行上下文的操作：State Tree Execution Context

状态数执行上下文是一个用于管理状态树执行过程的对象，他维护着当前状态和其他相关信息。状态句柄与状态数执行上下文交互主要体现在以下几个方面：

##### 获取当前状态

状态树执行上下文提供方法获取当前状态句柄，节点可以通过这个句柄获取当前状态信息。

```c++
FStateTreeStateHandle currentState=Context.GetCurrentState();
```





# 源碼學習：

### StateTreeType：

其实就是一个个”状态“的类，这里用Type表达类的概念。可以看作一个状态机的类。反正状态树就是一个个状态机之间的转换。



 分析下该StateTreeType的结构：

#### 首先是很多枚举类型【E开头的】：

**`EStateTreeStateType`**：**状态机类型。**定义不同类型的状态机。 State：普通状态机，Group:组状态机、Linked：链接状态机 、LinkedAsset：链接资产类型状态机

**`EStateTreeTransition Type`**：状态机转换的结果类型。定义转换的行为，None无转换，Succeeded成功结束，Failed失败结束等

**`EStateTreeTransition Trigger`**：**转换触发条件**。状态完成OnsStateCompleted 状态完成，OnStateSucceed状态成功。OnStateFailed转换失败，OnTick 每帧触发

**`EStateTreeTransition Priority`**：转换状态的优先级 。 





这个是FStateTreeDataHandle数据句柄指向的数据类型,是枚举类型E开头的

`EStateTreeDataSourceType`



#### 结构体类型：

**`FStateTreeStateHandle`** ：**状态树状态句柄。**表示状态树的状态，这个和状态机进行区分。提供了一些状态索引的管理和有效性检查等功能。  

**`FStateTreeDataHandle`**：**状态数数据句柄**。 表示状态树的一个数据，提供数据源类型、索引和关联状态句柄的管理和有效性的检查。

比如状态树中的一个状态机，。他的类型需要关联其他状态机，那么就是用这个句柄进行调用，句柄中有相关函数FStateTreeDataHandle,传入参数即可使用。



```

```

`struct STATETREEMODULE_API  FCompactStateTreeState`运行时展示在编辑器中的相关属性



### StateTreeExecutionType:



这个类很有用，适用于执行状态树的类，你看看他的文件名就知道是干什么的了，Execution。
FStateTreeExecutionFrame 这个结构体非常重要。它属于FStateTreeeExecutionContext的一部分，用于**FStateTreeExecutionFrame**





2025年4月18日

创建状态树的时候有两个父类可以继承创建，区别是什么？一个可以将AI Controller作为上下文，一个不行

<img src="..\Snipaste\State的继承.png" alt="State的继承" />

<img src="..\Snipaste\State区别.png" alt="State区别" />



# 土狗AI设计思路：

三次警告状态实现：

状态中设置一个定时器一次定时器结束之后刷新定时器，最后一次警告状态结束之后 对玩家进行攻击状态

接口：BPI_Mgr

管理类：BP_M_EgetW

当玩家切换武器立马调用接口将数据发送至管理器类中，敌人实时获取管理器中信息状态，然后通过管理器中数据转换状态树中状态

或者说状态树可以直接从管理器或者相关状态，然后直接转换？这样就省的在敌人蓝图获取一次？

**statetree可以绕过具体的enemy给敌人数据**，直接通过管理器获取信息，玩家信息只需要传递到管理器中

求值器只要是output，就能获取其对象内部变量

### 敌人相关具体动作实现

任务中获取挂载该状态树的行文很简单。

只需要创建一个Pawn类型的变量

然后设置为Input

若要实现相关功能

敌人身上实现接口即可。

然后在任务中调用接口



StateTree中在Event EnterState的节点后连接AIMoveto会造成卡顿，所以连接在tick事件之后，只有成功到达玩家身边才进行结束任务，合理！！



### 同一状态下，任务并行执行：

还有好像几个任务在一个状态中运行的时候会同时执行，导致我的敌人达不到我想实现的效果，所以注意这个问题

**在虚幻引擎的 State Tree 中，当一个状态中有三个任务时，默认情况下是同时执行的。**

State Tree 旨在提供一种并行处理任务的方式，允许不同的任务在同一状态下独立运行，从而实现更复杂和灵活的行为逻辑。每个任务都有自己的执行流程，它们可以各自独立地进行初始化、更新和完成等操作，相互之间没有严格的顺序依赖。

### 状态树怎么运行EQS?

我也是想的直接statetree任务中运行eqs，但是有问题了。

<img src="..\Snipaste\State运行eqs失败.png" alt="State运行eqs失败" style="zoom:50%;" />

runeqs是一个异步函数，所以说返回的是空的.

难道说要在StateTree中运行behaviorTree?

不，根据其为异步函数，还是可以解决的，引擎自带事件分发器，所以在使用的时候可以bind，当其完成的时候，调用自定义事件，然后通过返回的Locations中获取位置然后moveto即可

然后移动的时候需要将视角时刻保持在主角身上，tick函数中设置下即可



### 装备武器

**设置为StateTask**，因为被打的时	候与警告都要用得到，有一定的可复用性

装备武器是在Attention的时候开始调用接口，然后Enemy装备武器，

### 显示警告UI

在哪里显示？配表显示？？还是直接在状态树暴露参数显示？我的建议是配表存储在Pawn中，方便统一管理，对的，放在状态树中的话，如果多个ai用一个状态树的话，若是要显示datatable不一样就不好整了

### 放下武器之后UI还在显示

那就警告的时候，set visibility √  ，警告状态结束，调用接口，设为不可见





2025年4月27日

### escape

添加状态 escap 如何触发到此状态。攻击玩家时血量下降到某一阈值开始逃跑，还是说任何情况下，只要血量小于xx都逃跑呢？

攻击玩家状态时，血量小于xx转换为escape，因为砍一刀就能进入攻击状态。

##### 过程：

逃跑时调用Enemy的escape接口

escape接口实现将逃跑信息传递到Manager

Enmey再实现一个接收呼救信息的接口，创建一个同名任务。任务中确保Instigator！=self

状态树获取Manager中的结构体信息。

该信息在Move到目标点的时候使用。


### inverstigate

调查也只在巡逻的时候可以转换为调查状态。



通过中介者模式 其他npc发送信息到manager 监测此属性，若检测到则去调查。信息结构体。发送人，发送位置，。因为所有人都能接收，所以在接收的时候要判断发送者不是自己，不然可能导致自己刚发送又去调查了。

创建Condition 转移条件 ：C_toInvestigaor





在管理器random了一个police过去，那么意味着不用再进行审查是否是自身了，直接moveto



问题来了，当一个NPC看到我的时候另一个NPC也走过来了。设计的Mgr是不合理的。其不应该处理单独NPC的信息，而是处理几个NPC配合的信息

### 为什么调查之后没有回去巡逻而是一直在serach状态？

因为pawn的investigate还是true

在NOseeplayer的时候有一个tick监视isinvestigator这个值是否为true,为true则转换为serach状态，所以调查结束之后要将这个值置为false





普通NPC受击之后发送广播至NPC_mgr

mgr通过接收到的信息分配ai去调查？	

**外界信息如何影响AI状态，直接通过状态树监控ai信息，满足信息跳转状态即可**

状态结束记得将相关信息复原



2025年5月4日

学习到：

状态树可以链接其他状态树

状态树进行状态转换过程中可以通过tag在其他蓝图中进行更多的处理。比如击中目标之后使用sendStateTree Event进行传递

具体操作，在某一状态的Transiation中不是可以通过ontick 状态完成或者是on Event嘛，通过on event绑定一个tag

在其他蓝图中比如子弹碰撞事件，使用了sendStateTree Event.那么行为树的在此状态下，就会根据事件进行转移到其他状态。而不是根据浮点值，布尔等，是根据绑定tag进行的转移。

**任务执行完成之后记得改为其他状态**，不然一直回头吃饭

吃饭创建任务STT_Eating 通过蓝图接口，AI本身实现吃饭接口，播放动画蒙太奇嘛。

吃饭结束之后ExitState 状态tag改为默认，全局任务中的计算停止一下（clearHandle吗？）使其重新计算需求

#### 全局任务的妙用：

<img src="..\Snipaste\全局变量计算需求值.png" alt="全局变量计算需求值" />

在Enemy父类身上的需求值，初始化都为0，在游戏开始之后的过程中，需求值不断增高，然后去到目标地点{家，食堂}之后根据食堂中的补充速率进行需求值减少



状态添加：移动到食堂 /家、降低需求值 。需求值在状态为“降低需求值”状态的时候停止变化。

**铁律：制作状态树任务的时候除了需要锁定玩家或者敌人角色的时候参数为Actor，其他普通的或者玩家/AI的成员变量直接用对应的数据类型即可**



变化是在状态树中实时计算的。Ai身上的是设定的需求阈值

吃完饭之后怎么将全局变量中的计算值变为0呢？将累加的值其作为output扔出来？然后任务接收，在任务结束之后重新设置为0？

我草不用当成output，其他任务能够绑定全局任务中的值，但是怎么重设呢，哈哈

事件分发器？还是使用接口？

不重设这个累加值的话，直接用累加的值%预设的值为0就能循环使用了；

最终解决方案：

AI身上设置EatingTime,作为输入传给全局任务以及吃饭任务，全局任务在true之后delay这个时间将累加值设置为0即可，吃饭任务那边的时间从AI身上获取即可

<img src="..\Snipaste\全局任务重置吃饭需求累计时间完美解决1.png" alt="全局任务重置吃饭需求累计时间完美解决1" />



bugFIx 

看到其他pawn的时候ai将其添加到看到的数组中，但是后续获取的时候是get index=0的时候（只考虑了看到玩家，没考虑看到同类AI）,所以一直导致看不到玩家的情况。修改为for each所有看到的人，然后检测再是不是有Player。



修改之后出现新bug，AI与玩家talk之后离开，还会回头。

使用castto进行在AIpawn中clear focus接口中置空控制器中的数组

bug:感知更新看到的pawn数组会变为空，为什么

找了好久的原因，原来是将看到的actor置空的逻辑的放错位置了，变成了看到玩家就置空





RunEQS节点是异步的，所以在处理该节点使用的时候应该调用 bind Event to OnQueryFinished



### 更新：

血量低于40之后，有50%概率投降

如何区分正常对话，还是调查对话，我觉得应该分，枚举进行对话区分，

枚举值 正常打招呼对话，调查对话，怀疑对话，支援对话。

放哪？放对话任务中?作为变量保存还是说放在玩家身上？



### 投降：

对于头投降或者不投降的信息，应该传输到对应的enemy身上然后他们做出状态改变，进行继续攻击或者逃跑

怎么在uI中获取对应的正在投降的敌人呢？敌人进行show吗？



### 更新日志：

实现敌人巡逻时头部面向玩家。	动画蓝图中需要用接口获取玩家位置，并且通过look at 节点朝向玩家位置，主要是对该节点的处理和使用。

<img src="..\Snipaste\NPC转头.png" alt="NPC转头" />





嗯，就是依旧是运行行为树的，行为树中的一个任务再运行状态树。运行状态树的时候他俩处于共存转态。而且运行状态树的时候，这个状态树类型得是状态树AI组件类型的才可以使用。



状态树组件分为 状态树组件和状态树AI组件，一个不需要Controller的控制就可以运行，一个得需要在行为树中开启

1. 行为树可以运行状态树，但是运行的状态树类型是状态树AI组件才能够运行，并且这个状态树中要配置好对应的PlayerController和Pawn.

2. 一般情况下创建Ai的话还是使用StateTreeAI Component吧，我之前的AI是用的Statetree，并未使用Controller。

3. 非AI也是可以创建State的，比如天气状态，比如门状态等等非人物品



状态树修改：

当结束吃饭的时候需要将enemy上的is seeingplayer置为空，防止后续触发对话。

对话修改为不跟进玩家，而是在目视玩家



Enemy_418在没血之后将状态树关闭了。但是其他守卫应该是可以看到的。毕竟尸体是在地上。在基类身上应该有属性已经死亡，然后在其他守卫接收到这个信息之后开始进入调查状态，调查未果之后呢？调查有结果之后呢？

【enemyController】

嗯，是可以借助感知系统的，感知系统检索发现看到的敌人数组中有人是死亡状态，就转换为调查状态

【Pawn】Pawn上应该有变量接收相关信息然后改变对应变量之后就能实现准换状态树中状态，此时发现一个问题，stateTreeAIComponent是可以将Controller作为上下文的，



###### 解决状态树挂载在Ai上无法运行的bug

<img src="..\Snipaste\状态树开启.png" alt="状态树开启" />



#### 状态树组件区分

对于Actor状态树组件，一个Actor上可以运行多个状态树组件，可以转换运行。

对于Ai状态树组件：

常规配置 Controller上挂载状态树AI组件,然后Start Logic之后可以运行。

但是Pawn上挂载状态树AI组件,然后Start Logic之后不可以运行。

有节点 add statetree Component <u>该节点能够直接为Actor添加状态树组件</u>。 同样也有add statetreeAi component

换其他组件的时候记得stop当前的那个状态树的Logic 不然会同时运行两个状态树。

同时在通过add statetreeAi component之后也要记得Start这个状态树的Logic

##### 子类可以沿用父类状态树5

状态树中 Context Actor Class，某一个被选定的类的子类是不是也可以使用该状态树。

验证后发现，确实是可以！

Category可以通过改变进行一些操作，比如：

- Context： 自动绑定Actor
- input：选择Actor相关的属性进行绑定
- output：输出

使用finish Task 可能设计状态的转换，你可以在一个状态中设置有多个任务，但是只有一个任务中使用了finishTask节点，这样才会进行状态转换。



嗯。。在任务中设置定时器很简单呀，为啥给我的感觉每次都是很麻烦

首先就是在 Enter State的时候使用Set timer by event ，可以将时间设计的间隔大一些，这样就是能节约性能。

然后再使用创建Event用于后续【比如检查逻辑】。，如果检查相等的时候再进行finish Task

最后需要在完成任务的时候，clear一下句柄吗？需要！

##### FinishTask任务节点的巧妙使用：

<img src="..\Snipaste\finishTask的巧妙处理.png" alt="finishTask的巧妙处理" style="zoom:50%;" />

<img src="..\Snipaste\finishTask的巧妙处理2.png" alt="finishTask的巧妙处理2" style="zoom:50%;" />

还有就是注意：

##### 状态树的自动启用

应该在完成某些需要的引用已经创建之后再手动通过Start logic进行启动状态。

<img src="..\Snipaste\状态树自启动需要注意的.png" alt="状态树自启动需要注意的" style="zoom:50%;" />

##### Group:

状态的Type为Group的时候：

<img src="..\Snipaste\状态树Group.png" alt="状态树Group" style="zoom:50%;" />

对于组来说，我们应该明确组是一个逻辑概念,<u>其用于构建和组织逻辑结构</u>，当一个状态设置为组的时候，应该不执行任何Task。事实上也确实没有任务可用，所以再其他状态转换过来的时候，应该直接转到该组中的子状态中。

<img src="..\Snipaste\状态树。组.png" alt="状态树。组" style="zoom:50%;" />

<img src="..\Snipaste\状态树。组2.png" alt="状态树。组2" style="zoom:50%;" />

也要明确状态额父子关系，子状态激活的时候，父状态也会被激活。





也就是状态转换到某一子状态的时候，父状态都会被重新激活？也就是说一个父状态下的两个子状态转换的时候看，父状态会激活两次？

貌似可以根据任务中的类默认设置进行改变

<img src="..\Snipaste\状态树Task的类默认设置.png" alt="状态树Task的类默认设置" />

### Evaluators

​	评估器，概念上与任务有本质区别。

评估器的作用：

​		收集数据并评估这些数据。然后这些数据被评估后可以被状态树或者状态树任务用来做决策并触发状态转换。也就是说评估器提供状态树评估逻辑所需要的数据，但是并不会触发实际的状态转换。 

> 没看太懂和任务有啥区别，全局任务不是也能做这个事情。

- 评估器通常用于设计对场景中对象的引用，比如玩家角色或者玩家控制器。
- 计算演员之间的距离或者执行射线检测提供碰撞结果以执行操作。这些代码应该放在评估器中做数据收集以及变量计算。
- 评估器是状态树资产详情的一部分，其可以访问Context和Parameters.
- 评估器后面的任何事都无法被访问。 这是什么意思？
- 全局任务和整个状态树都可以访问评估器的数据。评估器启动时间和状态树启动时间相同

优势：可以在evaluator栏查看所有数据。这些数据都能够显示在状态树中。就是很方便通用，在多个任务需要使用这些数据的时候就可以直接调用了。【想起来了，之前一个任务中计算的结果我还想将其作为output供其他任务使用呢,有点麻烦】。只要评估器上计算的是简单数值，就不会对性能产生大量影响。	如果怕影响性能过大，就合理的创建计时器降低频率。

emm..用处的话，比如在判断门和玩家之间距离的话，是创建了一个任务进行处理的。可以用评估器进行计算。

### Enter Condition

这是一个强大的功能，但是常常被忽略。

这些条件独立于任务运行，能够提供额外的控制层处理。就是简单且能够复用的任务。然后条件的话只需要在每个状态设置不同的Enter Condition即可。 

比如状态树是玩家满足两个条件之后能够将门从关闭改为开启状态，但是后期有其他添加的逻辑，就可以直接在“门开启”状态下的Enter Condition 添加其他条件（比如主角是否有钥匙卡）而无需修改主要逻辑。【拓展：是否持有钥匙卡，就可以用标签表示，这样好像很方便，不用再创建变量，只需要统一在tag里设置。】

但是这是在该状态进入时设置的条件，当进入失败的时候后续怎么处理呢，失败会返回到根啊。

解决方法可以是加一层中间层。添加一个父状态：尝试进入开启的门的状态，通过提供一个回退状态，然后再设置一个无钥匙的警告状态，此状态两秒之后再次转化为门关闭状态。这样通过添加一个中间层很好的完成我们预期的结果。

<img src="..\Snipaste\状态进入条件的后续处理.png" alt="状态进入条件的后续处理" />

还有就是通过在评估器中设置不同的 statetree tag就能够在状态树中使用标签进行处理状态转换。

后面就是巴拉巴拉讲的Translation中的转换条件，这个我用的多啊，这个方便。这里多余需要注意的是某个转换条件不满足时，要添加一个备用转换路径。(就是在处理一个Event转换的时候创建两个translations有一个转换是包含if的，有一个是没有包含的)

<img src="..\Snipaste\状态树。备用转换.png" alt="状态树。备用转换" />

状态上的参数：

这个通常就是点击某一状态看到的，这个就是状态的局部参数。而状态树上的参数，那个是全局参数。



### 5.6更新信息

- 可以自定义tick频率，这样就很方便的能够减少开销，设置tick policy 设置为allowed之后，每个状态都能自定义频率时间。就是Event Tick的override。


- 增加了对单个状态下，任务完成的控制，可以选择全部任务都完成再出发过渡，也可以选择任一任务完成就出发状态转换。
- 能够在任务中通过状态树转换节点进行状态转换，转换到特定状态。5.5是没有这个功能的。
- 任务中能够创建事件分发器和监听器，比如一个状态中有多个任务，在一个任务完成后可以触发事件分发，然后下一个任务进行监听。这样就能实现任务顺序执行。
  - 分发，监听都创建好了，问题来了，这两个是分别创建的，怎么绑定使用呢？
  - 通过公开这两个之后，可以在状态树界面，点击任务上创建的监听器，可以选择某一个分发器进行监听。 

<img src="..\Snipaste\状态树。5_6更新信息.png" alt="状态树。5_6更新信息" />

<img src="..\Snipaste\状态树。5_6更新信息_委托.png" alt="状态树。5_6更新信息_委托" />

- 然后就是在左上角windows上有一个binding窗口，这个binding窗口可以看到所有绑定关系。

<img src="..\Snipaste\状态树。5_6更新信息_binding.png" alt="状态树。5_6更新信息_binding" />
