# C++中类的大小由什么确定

反应：成员变量的大小以及虚继承的基类的个数，虚继承的话会对虚基类指针指针个数有所影响



标答：

1. 非静态成员变量的大小

    因为如果有静态成员变量的话，他是存储在全局数据区的，不占类的内存大小

   

2. 内存对齐和填充

```c++
#include<iostream>

class B{
	 char c;//1字节   其要填充七个字节
	 double d;//8字节
};
int main(){
	cout<<sizeof(B)<<endl;//输出16
}

```

**原因：**在类中所有的成员变量 他的内存大小必须填充为最大内存的成员变量的数据类型的大小的倍数

3. 虚函数的影响

虚函数表指针嘛，64位系统中虚表指针大小为8字节。

```c
#include <iostream>
using namespace std;
class C{

	virtual void func(){} //引入虚函数指针 8字节
	int x;//4 字节
}

int main(){
	cout<<sizeof(C)<<endl;
}
```

有虚函数指针的话，也要记得类的内存大小必须填充为最大内存成员变量数据类型的大小，也就是一个指针八字节。**注意类中增加的是虚表指针的大小，无论多少的虚函数都无所谓的！！**

所以输出是16字节



![局部截取_20250316_224019](.\Workiong_File\snpi\局部截取_20250316_224019.png)

4. 虚继承的影响

上篇说过了，这个虚继承的话子类中是有保存父类的虚基类指针的



```c++
#include <iostream>
using namespace std;
class Base{
	int a;
}
class Derived: virtual public Base{
	int b;
}
int main(){
		cout<<sizeof(Derived)<<endl;
}
```



Derived虚继承的话会有一个指针Ⅷ字节，那我们想一下，是不是加上基类指针，加上基类成员变量和自身成员变量，内存对齐的话，是不是就是16了呢？

使用vs编辑器的话结果是24 但是用g++编译器的话，输出的就是16.



**那为啥vs编辑器下输出字节数是24呢？**

1. 因为在vs编译器中会有一个基类缓存空间，也就是基类的大小（这里是4字节）

2. vs给父类的缓存空间和**派生类自身大小**(b和虚基类指针)的内存空间不是连续的，两段空间上进行内存对齐

   

![局部截取_20250316_220253](.\Workiong_File\snpi\局部截取_20250316_220253.png)

5. 空类的大小 、

 那空类大小是多少呢？不是0哦，是1.

为什么呢？

在C++中要区别每一个类的地址，那么如果空类大小都是0的话，就没办法区分每一个类的地址了

项目中有多个空类的时候，所以要区分他们就要给每一个空类都占一个字节大小，保存每个空类的存储地址



# 详解虚函数





派生类中存在多个虚函数的时候，访问不同的虚表，this指针需要有不同的偏移





# Extern C的作用



#### extern 单词含义：“外部”

作用：extern C 是C++提供的关键字，告诉编译器按照C语言方式**编译和链接**函数或者变量，以解决C++名称修饰带来的兼容性问题。简单来说就是为了能够在C++代码中调用C语言代码，在C语言代码中调用C++代码。

#### 为什么需要extern C?

C++名称修饰问题【名称修饰是什么】后面有一个专门的小节解释

- C++支持函数重载，所以编译器会在编译的时候**修改函数名**，加入参数类型信息。

- C语言不支持重载，其函数名编译后不会被修改

如果C++直接调用C语言（没有extern C）的话，链接时找不到匹配的名称，会报错的

#### extern C的使用方式:

函数声明之前加入extern C 的引入方式

```C++
#include<iostream>
using namespace std;
extern "C" void Func(int a){
cout<<"a:"<<a<<endl;
return 0;
}
```



这里编译之后的话，是不会进行名称修饰的也就是编译之后这个函数名依然是Func

###### C++调用C语言：

```c
这是C语言头文件 c_lib.h
#ifndef C_LIB_H
#define C_LIB_H
#ifdef _cplusplus
extern "C"{
#endif
void C_function();
#ifdef _cplusplus
}
#endif

#endif
}

c语言文件 c_lib.c
#include<studio.h>    
 void C_function(){
    printf("this is c function");
}
```

```c++
#include<iostream>
#include "c_lib.h"
int main(){
	C_function();
}
```

结果能够成功输出this is c function,但是如果没有  extern C就会出现找不到函数的情况

那这个时候就有小朋友问了 **为什么呢？**不是说C语言编译的时候是不会进行名称修饰的嘛？那C语言的函数不就是不会变嘛，那为什么还找不到呢？



- 孩子，你猜猜C++中有没有调用这个函数，调用函数编译器就会处理这个函数名，在C中编译之后确实没有变，但是在C++中编译器修改了啊。，这就导致在链接器链接的时候找不到对应的函数，那就会出现链接错误。

###### C语言调用C++    

也是反之亦然的。





#### 那extern在什么情况下可以使用呢？

```c++
 适 用 于  ：
函数

extern "C" void func();


大括号括起来多个函数
extern "C"{
	void func1();
	void func2();

}

变量
extern "C" int global_var;

整个头文件（推荐做法）

#ifdef __cplusplus
extern "C"{
#endif


#ifdef __cplusplus
}
#endif


```

#### 那些情况用不了extern "C"呢？

- 不能修饰C++类，C语言不支持类
- 不能修饰函数重载，因为C语言不支持函数重载
  - ​	你给他整成extern "C" 的话，那对C语言来说，不进行处理，还是原函数名，它区分不了啊



#### 实际应用场景：

实际应用场景的话就是一些硬件啊，驱动啊，或者一些C库openCV等，又或者是封装一些C接口给python等语言





# 名称修饰

Name Mangling 也叫名称改编，名称粉碎。他是编译器对函数名、类名、变量名等标识符进行处理的一种技术，目的是让他们在目标文件和链接过程里具有唯一性

##### 为什么要名称修饰？

- 函数重载：C++支持函数重载，也就是允许在同一定义域内定义多个同名但是参数列表不同的函数，编译器为了区分这些同名函数，会对函数名进行修饰；
- 命名空间和类：不同命名空间或类中可能存在同名的函数或者变量，为了避免链接时候的命名冲突，编译器会对他们进行修饰

##### 注意

- 名称修饰规则因编译器而异，**不同编译器生成的目标文件**可能无法直接链接
- 名称修饰之后的代码难以阅读，这对程序员来说阅读毫无意义，但对编译器来说是不可或缺的，因为没有名称修饰可能无法区分重载函数或者不同命名空间的同名函数等









