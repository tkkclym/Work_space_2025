# Static关键字

主要用于控制变量和函数的的生命周期、作用域以及访问权限。

1. ## 静态变量 

- 函数内部使用static关键字修饰的变量称为静态变量

- 静态变量的生命周期：整个生命周期都存在，不会因为离开作用域而销毁

- 对基本数据而言，静态变量默认初始化为0

- ```c++
  void exampleFunction(){
  	static int count =0;
  	cout++;
  	cout<<"Count: "<<count<<endl;
  }
  
  ```

  

2. ## 静态函数 

- 类内部使用static 关键字修饰的函数为静态函数

- 静态函数属于类而不是类的实例，可以通过类名直接调用，而无需创建对象。

- 静态函数不能直接访问非静态成员变量或者非静态成员函数。

- ```C
  class ExampleFunction{
  public:
  	int Non_statVar;
  	static void staticFunc{
  	cout<<"Static function "<<endl;
  	}
      static void getNon_var(){
         	cour<<Non_statVar<endl;//将会报错，因为静态函数不能直接访问非静态成员函数
      }
  }
  ```
  
  ### 作用：
  
  工具类作用：静态成员函数不依赖于类的实例，它可以作为工具类的函数，提供一些通用的计算或者操作。例如，在枪战游戏中，计算两点之间的距离、判断两个物体是否碰撞等操作都可以封装在静态成员函数中。



3. ## 在类中做成员变量的时候

静态成员变量，需要在类中使用static修饰的成员变量。**所有类的对象共享一个静态成员变量的副本**。所以静态成员变量不属于任何实例对象，而属于整个类

静态成员变量必须在类的外部单独定义 ，以便为其分配存储空间。

也就是在类内部声明，在类的外部定义

```c++
class ExampleClass {
public:
	static int staticVar;
};
//类外定义并初始化对象
int ExampleClass::staticVar=0;
```

**注意:**静态成员变量不是Const 常量，所以是可以被修改的，在类外要修改的话可以直接修改。

在类外 若使用 成员函数修改，也可以使用非静态成员函数进行修改，因为静态成员变量可以在任何地方访问到。

而静态成员函数的意义就是，可以直接在类外调用，而不用创建类对象





总结：静态函数不能直接访问非静态变量，非静态函数可以访问（静态非静态都可以访问到，因为静态的是全局变量了，任何时候都能访问到。非静态的就是指常规的变量，当然自己的变量也可以访问到）。



为什么**静态成员函数**不能调用**类的非静态成员变量**？

因为静态成员函数**属于类本身**，而**不依赖于实例存在**，在程序编译的时候就确定了静态函数的地址。 静态成员函数没有隐含的this指针，因为this指针指向类的具体实例对象，而静态成员函数不与特定对象关联，所以**无法获取常规的类的变量**（即非静态成员变量）

*但是从调用方面理解的话：*

静态成员函数可以直接通过类名调用，也可以通过对象调用（可以被实例当工具使用，但是不依赖具体的类实例）



同时我们反观**非**静态成员函数及变量：非静态成员函数和变量是与类对象那个相关的，每个对象都有自己独立的非静态成员变量副本。创建一个对象的时候，系统会为该对象的非静态成员变量分配内存空间。非静态成员函数可以通过this指针访问调用该函数的非静态成员变量。

从调用方面理解：非静态成员变量和函数必须通过类实例对象访问，因为他们和对象是从属关系。





静态局部变量：

函数内部 使用static关键字 修饰的 局部变量 是静态局部变量 

存在于某函数中，但是生命周期延长至整个程序执行过程。但是只在声明他的函数中可见

```c++
void exampleFunc(){
	static int localVar;
    localVar++;
}

```

