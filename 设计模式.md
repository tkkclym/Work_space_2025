中介者模式在中介检测不到管理的对象怎么办？

首先应该在对象注册阶段就对对象进行处理

1. 对象注册机制的完善

- 要保证所有对象都能在初始化时向中介者完成注册，并且在销毁时进行注销


2. 心跳检测机制的实现

- 中介者可以定时向各个对象发送心跳包，以此确认对象是否处于活跃状态。


3. 异常处理与降级策略的制定

- 在中介者的核心方法中添加异常处理逻辑，防止因某个对象的故障而导致整个系统崩溃。


4. 状态持久化与恢复功能的添加

- 中介者可以定期保存系统状态，以便在对象恢复后能重新同步。


5. 动态发现与重新注册机制的建立

- 支持对象的动态注册，这样当对象恢复正常后能够重新加入系统。



# **VOID MATRIX**

类是对象的模板，是生产具体对象的蓝图；

**属性修饰符:**哪些是公开的，哪些是私有的，哪些是受保护的，也就是public，private，protected。作用：避免外部任意修改造成的混乱，注意，这并不是说明程序上是安全的。<u>属性的访问权限修饰符与程序安全性无关。</u>其限制的仅仅是开发者在编写代码时语法上的访问行为。

#### 三大思想：封装继承多态

为什么要封装？封装把类的变量藏起来，然后还要设计get/set方法的接口来访问，这会导致代码很臃肿，诚然，这会导致代码量增大。但是对于工程实践来说，这反而是最重要的，能够提前将可能出现的问题在编译阶段就暴露出来，能够减少很多人为因素造成的影响。

继承描述了类之间的关系。让一个类继承另一个类的属性和方法。

多态就是在运行时无需根据他们的具体类型去手动指定逻辑调用 。（已经快熟烂了这块~）

#### 重载、重写：

接着就引出了重载和重写有什么区别：

重载指的是<u>同一个作用域内</u>定义多个同名函数或者运算符，但是参数列不同，重载允许一个函数名根据参数的**类型、数量、顺序**来执行不同的操作。重载函数是根据编译时的参数类型来决定调用哪个版本的函数，这叫静态绑定。

重写指的是在子类中重新定义父类继承来的虚函数，重写允许子类修改父类方法的实现达到动态多态的效果。重写函数的函数签名：返回值，参数类型、数量必须和父类的虚函数完全相同，<u>重写的函数是在运行时调用的，这叫做动态绑定</u>。

#### 抽象类、接口：

抽象类是包含至少一个纯虚函数的类【其他函数可以是正常函数】，纯虚函数是没有实现的函数，其仅仅在基类中声明，但是需要在派生类中实现，所以其无法实例化。

抽象类的目的是作为其他类的基类，提供接口的约定并允许派生类实现具体的接口。比如一个在聚类的抽象，其能够提供一个纯虚函数move.`virtual move()=0`,还有正常的get,set name的方法，但是其不能够被直接实例化，而是需要派生类实现Move函数之后才能被实例化，

所以抽象类可以看做面向对象抽象过程中的一个不完善阶段，提供了一个实例具体的描述，但是又不够具体，只有填充更具体的描述的子类，才能产生实例子



接口在c++中并没有具体语法，但是可以通过纯虚类实现接口功能，纯虚类也就是只包含纯虚函数的类 。

面向对象是思想，是尽可能避免人为失误的工程规范工具、准则





### 面向对象的六大设计原则：

首先明确设计原则是什么，为什么要有这些原则，起到了什么约束作用。

设计模式是优化程序架构的指导思想。可以不用，但是程序结构丑陋和臃肿。但是不能硬搬设计模式，使用其的最佳策略是适度使用。

#### **单一职责原则：**

 一个类承担一种功能。

为什么？

- 降低耦合度，一个类只做一件事的时候，出问题也就容易定位和修复。
- 增强可读性和后续的可维护性。
- 复用性：拆分不同职能后，每个类都能够在其他场景中重复使用。那渲染来举例，一套图片纹理或者是动画，本质是数据，而不是灵活多变的逻辑，所以更进阶的设计是只使用数据化的渲染命令，将需要渲染的数据提交到渲染队列，由更底层的引擎层面接管。

但是如果只使用单一职责思想会使得代码繁杂冗余，所以我们会考虑组合模式的思想。

#### **开闭原则：**

对拓展开放，对修改封闭。【怎么理解？】:当需求改变时，我们需要修改已有的代码功能或者添加新的功能模块时，尽量拓展新的代码，而不是修改已有代码。 

为什么？因为能跑就行，修改原有代码不一定会触发什么bug,所以在原有代码的基础上进行拓展的话可以降低风险。谨防<u>侵入式修改</u>

#### **里式替换原则：**

一句话概括：所有父类出现过的地方都能够使用子类对象来替换，而不会改变程序的正确性。就是继承中要求的思想：子类是父类更具象的描述且遵循父类相同的功能。

![里氏替换原则](..\Work_space_2025\screenshot\设计模式\里氏替换原则.png)

#### **接口隔离原则：**

就是设计接口时，应该将一个大而全的接口拆分成更小，更精细的接口。

#### **依赖倒置原则：**

高层次的类不应该依赖低层次的类，而是将二者的依赖转嫁到抽象接口上。

什么是高层次、低层次？

不是父类和子类，而是软件层面的上层业务和底层架构。

低层次的类：文件IO,网络通信，数据库连接，，

比如高层次的Game类，也就是游戏业务逻辑类，在设计之初依赖低层次的TCP网络通信类，后期需要更换为UDP了，难道要在代码中找到所有的接收的接口进行替换?这显然是不合适的。所以我们应该在设计之初怎么办呢？抽象出NetWork接口，提供send和recv两个方法约定。而Game类并不直接依赖具体的TCP或者UDP的实现，仅调用NetWork抽象的send和recv。这样当我们切换低层次的实现时，高层次的客户端代码无需进行任何操作。

。。。。我草这对开发者架构能力要求好高，得做多久主程才能架构好游戏？所以在开发时，如果时间够的话，不要将业务类直接依赖具体的底层实现，**而是要将用到的底层实现抽象出一层。**

#### **迪米特法则**

最少知识原则。

为什么要用迪米特法则？

降低耦合：减少对象间的依赖，防止单个对象变化引发链上其他对象功能的关键 

增强系统稳定性：每个模块只关注自己的直接关系，便于测试维护

## 

## 创建型模式：

关注对象创建时的过程，能够大幅提升创建对象时的灵活性和可复用性。通过延迟对象初始化过程，产生不同的具体产品。将创建该实例的操作交给了另一个类，也就是具体工厂，而具体工厂又可以抽象出一层工厂基类。	

### 工厂方法模式

Factory Method.

假如不使用工厂模式：

​	有一个Weapon基类，然后剑和弓继承此类，那么就可以直接实例化这两个类。

如果使用工厂模式：

​	就需要创建一个Factory工厂类，然后工厂有一个createWeapon抽象方法，`virtual Weapon* createWeapon()=0;`返回的是父类Weapon指针，然后继承这个工厂实现剑和弓工厂的创建。

```c++
class Weapom(){
public:
    virtual Weapon* createWeapon()=0;
    virtual ~Weapon()=0;
}
class SwordFactory:public WeaponFactory{
public:
Weapon* createWeapon() override{
	return new Sword();
}
}
class BowFactory:public BowFactory{
public:
Weapon* createWeapon() override{
	return new Bow();
}
}
```

【要素】：

抽象产品：如Weapon基类

具体产品：如sword和bow

抽象工厂：也叫创建者，其不直接进行具体的产品创建。而是负责对创建的接口进行声明`virtual Weapon* createWeapon()=0` 后续所有的创建者返回的对象类型必须与产品的接口相匹配

具体工厂：重新抽象工厂方法，实例化不同的具体产品对象进行返回。



那为什么要抽象一层工厂出来呢？

其深层目的是什么？

#### 抽象出工厂的目的：

1. 实现客户端与具体产品类的解耦。比如游戏中**只需要让玩家依赖具体的工厂类**，而无需关注产品的内部实现或者构造需求，这样就可以独立变更与角色控制相关的玩家类和实现具体玩法的武器道具类
2. 提高系统可拓展性。游戏出现新武器的时候，只需要创建具体工厂类，而无需改变角色或者已有的工厂类
3. 封装复杂对象的创建逻辑。
4. 遵循开闭原与单一职责原则。具体产品代码与使用该产品的客户端内容进行分离。武器的创建和使用，这个分属不同的步骤和职责。严格来说确实需要将二者拆分成不同类进行管理。
5. 提供可维护性。将对象创建代码逻辑集中到一处处理，避免将武器对象构造和初始化散落到玩家类各处。



#### 工厂模式总结：

- 简单工厂模式：用一个工厂直接生产所需的对象。优点：实现简单。缺点：不符合开闭原则，也就是增加新的产品对象是，需要修改工厂代码
- 工厂方法模式，在简单的工厂基础上抽象出一层工厂类【常用方法】,有新产品的时候，只需要增加一个具体的工厂子类，而不需要修改工厂类的代码。符合开闭原则。缺点是工厂子类过多时，代码重复性过高。
- 主要用于创建单一类型的对象：工厂模式的工厂通常负责创建一种特定类型的对象。客户端只关心如何获取该类型对象，而不需要关心对象的创建流程。

### 抽象工厂模式

假如战士和巫师都有攻装和防装，抽象工厂划分为了能够生产一个攻装和一个防装的工厂，然后具体一层就是战士的攻装和防装的工厂，巫师的攻装和防装的工厂。

 当需要创建一系列相关的产品对象，并且希望它们能协同工作时。使用抽象工厂

【要素】

抽象产品：如Weapon类，Armor类 也就是武器和防具，纯虚类

具体产品:如Sword，shield,Staff和Spellbook，是最终别工厂实例化的目标

抽象工厂：声明一组接口，创建抽象产品，随后定义的所有具体工厂都应该能够生成对应的成套产品

具体工厂：实例化具体产品，这样客户端只需要调用抽象工厂的接口就能完成与具体工厂的和产品的交互。【？调用抽象工厂】其实还是与具体工厂交互

【应用场景】

- 跨平台GUI，如Qt，GTK+对不同平台UI组件进行封装
- 游戏文件系统，不同OS上文件API是不同的
- 渲染接口不同。对纹理，着色器，缓冲区进行抽象能够兼容openGL，VulkanDirectX等不同后端。

#### 相较于工厂模式优势在哪里？

更多维度的可定制化，可以根据不同的产品变种提供具体的创建逻辑。

抽象工厂模式创建的是一系列相关产品，而工厂方法模式创建的是单个产品。

缺点:更多的类，更多的代码，抽象和理解更加复杂。

结合代码理解：

能够创建一系列关联的对象，抽象工厂生产的是组合的数据，这些数据共同产出一个产品。

当需要新增一种产品（比如变速箱）时，需要修改抽象工厂接口以及所有具体工厂类，这可能会违背开闭原则。

我的错误思路指正：客户端依赖抽象工厂层。并不是具体工厂层。因为**传入的参数是抽象工厂指针。**

```c++
#include <iostream>
#include <memory>
#include <string>

using namespace std;
//抽象引擎类
class Engine{
    public:
    virtual string start()=0;
    virtual ~Engine()=0;
};
Engine::~Engine(){}
//具体引擎类
class GasolinEngine:public Engine{
    public:
    string start()override{
        return "燃油发动机";
    }
};
class ElectricEngine:public Engine{
    public:
    string start()override{
        return "新能源发动机";
    }
};
//轮胎类
class Tire{
    public:
    virtual string roll()=0;
    virtual ~Tire()=0;
};
Tire::~Tire(){}
class NormalTire:public Tire{
    public:
    string roll()override{
        return "普通轮胎滚动";
    }
};
class SnowTire:public Tire{
    public:
    string roll()override{
        return "疯狂雪地胎";
    }
};

class CarFactory{
public:
    virtual unique_ptr<Engine> createEngine()=0;
    virtual unique_ptr<Tire> createTire()=0;
    virtual ~CarFactory()=0;
};
CarFactory::~CarFactory(){}
class NormalCar:public CarFactory{
public:
    unique_ptr<Engine> createEngine()override{
        return make_unique<GasolinEngine>();
    };
    unique_ptr<Tire> createTire()override{
        return make_unique<NormalTire>();
    }
    ~NormalCar(){
        
    };
};
class SnowCar:public CarFactory{
public:
    unique_ptr<Engine> createEngine()override{
        return make_unique<ElectricEngine>();
    }
    unique_ptr<Tire> createTire()override{
        return make_unique<SnowTire>();
    }
};

void createCar(CarFactory &carfactory){
auto engine=carfactory.createEngine();
auto tire=carfactory.createTire();
cout<<"引擎:"<<engine->start()<<endl;
cout<<"轮胎:"<<tire->roll()<<endl;
};
//-----快速输出-----使用模板编程，我不想在后面一直cout<<xxx<<endl;直接用模板变成打印吧
void Print(){
    cout<<endl;
}
template<typename T>
void Print(const T&value){
    cout<<value<<endl;
}
template<typename T,typename U>
void Print(const T&first,U&second){
    cout<<first<<second<<endl;
}

int main(){

Print("常规车：");
unique_ptr<CarFactory>N_Car=make_unique<NormalCar>();
createCar(*N_Car);
Print("雪地车：");
unique_ptr<CarFactory>S_Car=make_unique<SnowCar>();
createCar(*S_Car);

    return 0;
}
```

#### 关于代码编译半天生成不了exe文件：

纯虚析构函数的特殊规则：

即使析构函数被声明为纯虚析构函数，也必须在类外提供其实现。因为派生类对象被销毁时，会先调用派生类的析构函数，然后逐级向上调用基类析构函数。如果基类纯虚析构函数没有实现，编译器将无法生成完整的析构代码。

纯链接错误的本质：

纯虚析构函数通常不需要实现（因为由派生类实现），但是纯虚析构函数是个例外。如果只声明而不实现纯虚析构函数，链接器会报错，提示“未定义的引用”



#### 总结抽象工厂模式：

-  负责创建一系列相关的对象：抽象工厂不再负责单一类型的对象，而是负责创建一系列相关的对象。
- 强调产品族的概念，每个产品族包含一系列相关的产品对象。具体的工厂子类生产一个特定产品族的所有产品对象。
- 代码复杂度高。



### 建造者模式

也叫生成器模式,相较于工厂和抽象工厂，建造者更强调的是步骤，而不是结构

**建造者模式将对象的创建和表示分离，使同样的建造过程可以创建不同表示的对象。**

比如关卡GameLevel的构造，关卡中有道具、敌人、障碍物等信息的数组，我们当然可以在构造函数中填充关卡信息，但是这样显然不够灵活。

所以引出一个LevelBuilder类用来创建关卡，关卡生成器 .所有具体用于生成关卡的子类生成器都应该实现设置关卡的各个方法 ，以及提供一个用于返回生成完成的关卡的关卡对象build方法。

【要素】

1. 产品 GameLevel ，构造过程中逐步完善初始化的对象。
2. 抽象生成器 LevelBuilder 作用：约定建造者需要执行的任务内容。
3. 具体生成器：EasyLevelBuilder  
4. 导演类、主管类:GameLevelDirector，游戏导演类。

【优点】

1. 简化构造参数 ：拆分单个类的构造任务到多个生成器步骤，避免构造函数的臃肿。
2. 灵活组合步骤： 通过对构造任务的单一职责拆分，我们可以解耦过程，从而使用组合灵活地产出更多变种的产品
3. 动态感知构造过程：借助导演可以在运行时根据构造过程调整各部分任务，暂缓创建或执行递归构造。--？？？？



### 原型模式

定义：原型模式是一种创建型设计模式，其主要思想是**通过复制现有对象（即原型）来创建新对象，而无需依赖显式的类实例化过程**。这种模式特别适用于对象创建成本较高或复杂的场景，通过复制已有实例可以显著提高性能和灵活性。

能够更优雅地实现对象的拷贝? 对某些对象的复制不用依赖对应的类

在一个RTS中，玩家能够生成弓兵，弓箭手，骑士等兵种。动态的根据一些条件生成这些实例。

首先定义原型接口

```C
class Prototype
{
public: 
    virtual Prototype* clone()=0;//克隆方法
    virtual void showInfo() const =0;//展示单位信息
}
```

所有能够实现复制功能的产品都应该实现这个clone接口

```c++
骑士类
class Knight:public Prototype
{
    private:
    std::string type;
    int health;
    int attack;
    int defense;
    public:
    Knight(std::string type,int health,int attack,int defense):type(type),health(health),attack(attack),defense(defense){}
    Prototype*clone() const override{
        return new Knight(*this);
    }
    void showInfo() const override
    {
        std::cout<<"Knight type:"<<type<<"\nhealth:"<<health<<"\nAttack:"<<attack<<"\nDefense:"<<defense<<std::endl;
    }
}
```

可以看到骑士类实现的接口函数 clone中，只是简单的调用了类的拷贝构造方法。

```c++
后期使用：
Knight* KnightPrototype=new Knight("Cacalry",150,20,10);
Prototype*cloneKnight=knightPrototype->clone();
cloneKnight->showInfo();
```

好像没做什么事啊。。

【为什么不选择--】

1.直接使用拷贝构造函数？

因为拷贝函数是静态实现，并不能精确控制拷贝范围。原型模式中，只要对象实现了clone接口就能够任意复制，完全解耦对具体类的依赖。具体类的内部可以自行决定要复制哪些字段，想复制一部分，那就只复制一部分，其他的不改变。

2.类外手工拷贝类内字段？

私有字段不易访问，产生依赖。

【典型案例】

1.预制体/场景实例化过程