# 最长递增子序列

--子序列问题，递归中的常见问题

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)



动规五部曲：

1， dp和i，j之间的含义

- dp[i]:以每一个**nums[i]为结尾**的最长递增子序列长度的最大值【注意这个结尾的字眼，说明最后以各个结尾的数组还要取最大值。】

2 确定状态转移方程

- 懂了，这个状态转移方程 就是与dp[i-1]中的最后一个下标的元素作比较，如果比他大就加1，这是一种情况【情况1】，如果不比他大的情况怎么处理呢？就是整个长度为i的数组中找最递增子区间呗【情况2】.然后这两种情况作比较，取dp较大的那个。

- 注意这里第二种处理情况怎么办没弄懂。为什么代码中没有写当不满足第一种情况时的相关代码呢？`·很多逻辑不必明写，已经隐藏在代码结构之中了，就像社会中的潜规则一样，等着你发掘·`

- 理解错误了。。规则理解错误，当nums[j]>=nums[i]的时候，dp[i]是不需要更新的，因为它接不到nums[j]后面了，也就不能够形成更长的子序列数组

  

  

  然后呢怎么处理得到递增的数组呢？。。额我想不出来，他也到下一步了，初始化。

  

  

3 初始化

- 长度至少都是1

4 确定遍历顺序

- 因为要跟前面的元素作比较所以依赖的是前一个元素的值，所以是从左到右
- 内层循环是为了遍历0~j的元素的长度在这个长度里  然后使用状态转移方程

最后我想着输出的话是不是还需要一个额外的数组进行存储，其实返回动态规划的数组就差不多的。但是注意返回的值是否符合题意还有待商议【这里是需要的，因为要在外层循环和内层循环之间更新每次和上一段数组长度的最大值】

5 打印字符串





#### 更正逻辑：

> ​	`·很多逻辑不必明写，已经隐藏在代码结构之中了，就像社会中的潜规则一样，等着你发掘·`

这句话还是对的，因为在双层循环中，我只记住了外层循环向后移动的逻辑，但是我没有记住，外层循环还会等待内层循环`j`, 在`j`从0循环到终止条件之前，`i`一直都在等他.

【希望你的`i`人，也会等你成功】

然后接着说，这个递推公式的处理的话，在i不动的情况下，会在`j`移动的时候更新dp[i] (dp[i]在之前初始化为1了). 【现在做到下一题返回上来。从连续的角度来看的话，这个j和i之间是有距离的哈，也就是对下一题来说这是不连续的情况了。】



```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
    	int n=nums.size();
        if(n<=1)return n;//只有一个元素或者没有元素的时候
        vector<int>dp(n,1);// dp[i]注意含义，以i结尾的，最长的递增子序列的长度
        int result=0;//数组长度i变化时求出取最长的子序列长度【细品】
        
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1);
            }
            if(dp[i]>result){
                result=dp[i];
            }
        }
    return result;
    }
};
```

# 最长连续递增序列

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

  

搞清楚连续递增和递增的区别，递增子序列是要求到最后一个元素看看是不是大于前面的子序列中最后一个元素。

但是连续子序列重要的是连续，连续。。 递推公式和上一个都不一样。只只考虑连续不连续就行，dp[i]=dp[i-1]+1

dp[i]含义就是，当在第i个元素时，连续子序列最长的长度?



以i为结尾的最长连续递增子序列的长度  至于起始位置是不是从0倒是无所谓

 

> 严格按照动规五部曲的架构

```C
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int n=nums.size();
        vector<int>dp(n,1);
      int   result=1 ;
        //需要暂存最长递增序列的
        for(int i=1;i<n;i++){
            if(nums[i]>nums[i-1]) 
            {
                dp[i]=dp[i-1]+1;
            }
            if(dp[i]>result)
            result=dp[i];
        }
        return result;
    }
};
```

//待总结，不行了我想先回家了.效率极为低下了，回家睡觉