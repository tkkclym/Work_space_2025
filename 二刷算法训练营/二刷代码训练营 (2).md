## 字符串总结：

有需要翻转操作的有三种选择，使用库函数reverse，自建reverse函数以及，直接在主函数中使用双指针对夹进行处理翻转。

三刷[翻转字符串2](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  .尼玛没想到双指针居然，大意了。

```c++
狗屎一样的做法，但是总结出来了很多，值了

class Solution {
public:
    string reverseStr(string s, int k) {
        //思路呢？每2k个字符翻转前k个，记得处理最后x<k以及k<x<2k的情况。题解中的方法很巧妙
        //处理字符串首先得遍历吧
        int n=s.size();
        for(int i=0;i<n;i++){
            //每2k个进行翻转
            if(i%(2*k)==0){//满足到2k个条件的时候
            //1.翻转前k个,怎么翻转？ w2:怎么使用min? w3：看解析使用的双指针，为啥呢？突然好想能够总结出一点，翻转的话，最好使用while配合双指针进行互相逼近，然后进行翻转操作
            while(k/2--){
                swap(s[i-2k+1],s[i-k])
                //....循环条件不对劲，对夹没有。k一大的话，只翻转了一次。
            }
            }
        }
    }
};
```

还是有些问题没理解透彻：

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
       int n=s.size();
        for(int i=0;i<n;i+=(2*k)){//初始化i;i的取值范围，单次循环结束之后对i的处理方式
            //每次转移2k个位置。
        int slow=i;
        int fast=min(i+k-1,n-1);//fast要注意了，处理最后的时候得小心
        while(slow<fast){
            swap(s[slow],s[fast]);
            slow++;
            fast--;
        }
    //结束的时候记得更新slow的位置，不然每次进for循环slow都是0
    //slow=i-2k-1.   //不对劲，这个处理没有任何意义。下次进入循环还是slow=0；我搞混了每次进入循环时后slow和fast相对本次循环的位置。
        }
        return s;
    }
};

1. 比如要考虑指针的创建时机，在循环外部还是内部，外层循环还是内层循环。
    
2. 理解好创建单层循环的意义，以及单层循环处理的是什么。不要将内外层循环处理的内容搞混
    
3. for循环的最后一个参数意义，是一次循环结束之后，定义的i的处理方式
```

库函数reverse使用：

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        //  使用库函数reverse翻转 其参数应该是迭代器
        for (int i = 0; i < s.size(); i += (2 * k)) {
            if (i + k < s.size()) {
                reverse(i + s.begin(), i + k + s.begin());
            } else {
                reverse(i + s.begin(), s.end());
            }
        }
        return s;
    }
};
```







刷题过程问题总结：

问题1：翻转前k个,怎么翻转？ 

- 使用双指针或者reverse库函数啊，man呆。

问题2：最后那段怎么使用min处理呢？

- 巧妙地使用min，但是注意min处理的是fast指针诶。处理的话，应该注重每次循环的通用性以及最后一次的特殊性。

- 这里fast指针使用min，`min(i+k-1,n-1)`,循环的最后一次用不用全部翻转，或者只用翻转前k个。i+k-1是下标。n-1也是。

问题3：你踏马怎么每次i只移动一个距离？每次一个距离性能开销有点高啊？

- 直接移动`2*k`,循环条件中表示也就是`i+=2*k`.   甲霸。









问题4：为啥使用双指针？我应该统计下双指针的使用场景了

## 双指针总结篇

基本用法就两种吧：快慢指针，对夹指针 重要的是指针移动逻辑

**数组中**，移除元素，for循环条件定义一个快指针进行逐个移动，定义一个慢指针，满足条件时候移动（不等于target）,等于target的时候只有快指针移动，这样慢指针就会在移动过程中覆盖掉等于target的元素。使用双指针优势就是将时间复杂度为O(n2)降为O(n).

**字符串篇**，翻转元素，[替换元素](https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html)，通过将空格替换成其他元素，从后向前填充元素使用双指针。

**哈希表篇**,三数之和通过双指针对夹，四数之和通过两层for循环依旧是双指针对夹，最终找出所有符合条件的数组。两数之和可以用哈希表法，**但是也可以用双指针**。

**链表篇**，还未进行二刷，[环形链表](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)是否有环以及出口问题。



# 栈、队列

C++中Stack是容器吗？

栈、队列和STL之间的关系是什么？

- 栈和队列是STL（C++标准库）里面的两个数据结构。

我们使用的Stack STL属于哪个版本？

SGI STL ，其被Linux的C++编译器GCC所采用，SGISTL其为开源软件，可读性很高



栈提供push，pop等接口，所有元素必须符合先进先出，所以栈不提供走访功能，也不提供迭代器（iterator）。不像map，set等提供迭代器用于遍历所有元素。

所以STL中的**栈不被归类为容器**，而被归类为容器适配器 container adapter 

**栈的底层**实现可以是vector,deque,list 。主要就是数组和链表的底层实现，我们常用的STL，如果没有指定底层的话，默认是使用deque作为底层结构的。deque：双端队列，封住一端只开通另一端就是栈了

我草可以指定底层实现结构，方法如下：

```C
std::stack<int,std::vector<int>>third;使用vector作为底层容器的栈
```

队列和栈基本是一样的！！

队列是先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为默认情况下的底层数据结构。

可以指定list为底层实现，初始化语句如下：

```c++
std::queue<int,list<int>>third;定义以list为底层容器的队列
```

同样队列也不被归类为容器，而是容器适配器 container adapter 

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

栈实现队列？第一次遇到。怎么做呢?

思路：构造函数怎么写呢？既然是使用栈实现队列了，构造的时候应该是使用两个栈进行初始化哈。初始化完成之后再进行其他函数的实现。

起初在疑惑为什么用两个栈实现呢?一个栈直接进完元素就出不就行了，乍一想没什么问题，但是不允许连续进多个元素呀。所以一个栈是没办法实现的。

所以题目要求使用两个栈，栈1栈2，用于解题，两个栈依旧想不出怎么使用，看了视频才知道。栈1中元素逐渐弹出添加到另一个栈中，栈2再弹出，此时的元素的出栈顺序就是和进栈相同了。

--注意栈1中元素1出栈的时候必须出完，不然会打乱整个的顺序 

也就是当栈2不为空的时候，如果要出队列操作，直接从栈2中弹出就行，只有当栈2在某一次弹出操作变空之后才会将栈1中所有元素直接加到栈2。【】

进队列操作的话：就是直接往栈1中加即可。

peek函数： int result=stackOut.top();这里不能直接从stackout中获取栈顶元素作为整个队列的首元素，因为stackout栈可能为空，还得从stackIn中转移到stackOut中，这个操作逻辑在pop函数中写过了，所以可以复用pop函数。



```c++
class MyQueue {
public:
    stack<int>stackIn;
    stack<int>stackOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stackIn.push(x);
    }
    int pop() {
        if(stackOut.empty()){
            while(!stackIn.empty()){
                stackOut.push(stackIn.top());
                stackIn.pop();
            }
        }
        int result=stackOut.top();
        stackOut.pop();
        return result;
    }
    
    int peek() {
       int result= this->pop();
       stackOut.push(result);
       //因为要的是栈2的栈顶元素，所以先弹出获取，然后再把这个元素放回栈2，有借有还，完美
       return result;
//        int result=stackOut.top();这里不能直接从stackout中获取栈顶元素，因为stackout栈可能为空，还得从stackIn中转移到stackOut中，这个操作逻辑在pop函数中写过了，所以可以复用pop函数。

    }
    
    bool empty() {
        if(stackIn.empty()&&stackOut.empty()){
            return true;
        }else{return false;};
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

queue的一些成员函数：

默认构造函数 ：queue();创建空队列

拷贝构造函数：queue（const queue&other) 通过复制另一个other队列来创建新队列

##### 元素访问：

- `front()`:返回队列中第一个元素的引用。若队列为空，则调用此函数会导致未定义行为。

- **`back()`**：返回队列中最后一个元素的引用。若队列为空，调用此函数会导致未定义行为。

##### 容量：

`empty()`：判断队列是否为空。空则返回true，否则返回false

`size()`:face_with_head_bandage:返回队列中数组元素。

##### :rocket:修改器：

push (const value_type&value):队列尾部插入新元素，值为value

`pop()`：:yum:移除队列中的第一个元素，**没有返回值**

`emplace`:队列尾部就地构造一个新元素，**没有返回值**



```c++
    int pop() {
        //弹出的时候先统计size吧,然后
       int n= QQ.size();
       while(n--){
            int result=QQ.pop();
            QQ.push(result);//得用front front 才有返回值，直接添加到队末
       }
       int E_result=QQ.pop();  //pop()没有返回值
       return E_result;
    }
```

这里就是为了实现功能，但是没掌握库函数的具体用法，是否有返回值等

```c++
class MyStack {
public:
    queue<int>QQ;
    MyStack() {
        
    }
    
    void push(int x) {
        QQ.push(x);
    }
    
    int pop() {
        //弹出的时候先统计size吧,然后
       int n= QQ.size();
       n--;//让循环运行n-1次。最后一个元素也就到了队列首
       while(n--){
            QQ.push(QQ.front());
            QQ.pop();
       }
       int E_result=QQ.front();
       QQ.pop();
       return E_result;
    }
    
    int top() {
        int n=QQ.size();
        n--;
        while(n--){
            QQ.push(QQ.front());
            QQ.pop();
        }
        int result=QQ.front();
        QQ.push(QQ.front());
        QQ.pop();
        return result;
    }
    
    bool empty() {
        return QQ.empty();
    }
};

```

### 括号匹配

三种不匹配的情况：

1左括号多余

2右括号多余

3左右括号不匹配

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.size()%2!=0)return false;
        stack<char>st;
        for(int i=0;i<s.size();i++){
            if(s[i]=='('){st.push(')');}
            else if(s[i]=='{'){ st.push('}');}
            else if(s[i]=='['){st.push(']'); }
            else if(st.empty()||st.top()!=s[i]){
                return false;//这个情况是还没遍历完s呢，栈都空了，也就是有括号多了的情况，以及左括号不等于右括号的情况
            }
            //下面这else就是以上所有if都不满足情况进行pop也就是左括号等于右括号的情况，将栈中的右括号弹出。
            else {st.pop();}
        }     
        return st.empty();
    }
};
```

还可以使用哈希表进行解决，因为我们进行了判断元素是否存在的行为嘛，有这个行为就可以使用哈希表；

```c++
class Solution {
public:
    bool isValid(string s) {
        //hash大法，右括号为键，因为查询的是有括号嘛，如果不是右括号就压栈，查到右括号就弹栈。
        unordered_map<char,char>mpp={
            {')','('},
            {'}','{'},
            {']','['}
        };
        stack<char>st1;
        for(char i:s){
            if(mpp.count(i)){
                    //查到了右括号，是不是要判断栈空不空以及是不是等于栈顶对应的value的情况了？
                    if(st1.empty()||mpp[i]!=st1.top()){
                        return false;
                    }
                    st1.pop();
            }else{
                //查不到，就是遇到的左括号嘛，直接压左括号就行
                st1.push(i);
            }
        }
        //最后依旧是 判断左括号是不是多余了，压在栈里遍历完s都没有弹出
        return st1.empty();
    }
};
```





### [ 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```javascript
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char>st;
        for(int i=0;i<s.size();i++){
            if(st.empty()||s[i]!=st.top()){ //重点1：记得应该首先判断是不是空，不然会报错的，注意顺序
                st.push(s[i]);
            }
            else st.pop();
        }
        string result;
        while(!st.empty()){
            result+=st.top();
            st.pop();
        }
        reverse(result.begin(),result.end());//重点2：记得翻转。
        return result;
    }
};
```

两个重点：

重点1：是和解决括号匹配时候遇到的栈空的情况一样的顺序问题： 应该首先判断栈是不是空的 再通过`||`连接是不是不等于栈顶元素，这样运行的时候就不会报错了。

重点2：在输出结果的时候不要忘记将结果翻转一下，因为这是栈，先进后出的性质在那里呢。

> 很简单的栈。循环消除相邻元素但是应该如果不是出现在集合中应该挺难想到用栈吧，所以所掌握数据结构就相当手里的工具嘛，看到钉子我就有锤子锤，看到木头我就有斧头劈.手里的工具数量也决定着我们解决问题的能力。所以那句话很对，如果你只有一把锤子，一切看起来都像钉子。





## part02



### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

我以为是滑动窗口的问题，然后回去复习了下[滑动窗口](https://zhuanlan.zhihu.com/p/1899149077704348555)的知识。还有想明白了一个群友的疑问，他的提问暗渡成仓的混淆了我们的最终目的。此题并不是相等就停止的呀，目的是求最小的子数组长度，那**就可能有很多相等的情况**，你怎么判断这次相等的时候就是长度最小的呢，所以要进入循环判断长度啦

<img src="..\Snipaste\群友问题.png" alt="群友问题" style="zoom:50%;" />

题外话说完了，接下来是本题的题解：

给一个数组，然后有一个滑动窗口，求出每次向后滑动一个位置的时候，窗口中的最大值。

这个窗口像什么呢？单调队列，每次滑动一次就是pop()一次然后push进了另一个数，每次都是这样，然后再获取经历过一遍这个之后的窗口中的最大值，所以我们要实现一个这样的队列。

#### 看视频解析问题：

**优先级队列**是什么？

C++中优先级队列的数据结构其实就是大顶堆小顶堆，但是使用这个是不被允许的，因为加进来之后，这个队列中元素顺序就被改变了，还有啊，移动的时候需要pop和push呢，那每次pop出去的都是最大值，这还怎么在下次进行比较呢？所以舍弃掉这种方法。 我们使用单调队列。

捏马为啥使用**单调队列**呢？为啥不使用普通队列呢?

- 因为他要维护一个最大值，并且队列出口位置的元素没必要维护，其本来就要被弹出。就是最大值之前的元素都要pop掉。
- 哦~又明白了，其实我是先入为主了以为这个队列中是已经有三个元素的，其实不是的，通过for循环一个元素一个元素加进这个“单调队列”的。 单调队列维护的话，就是出口处维护的是最大值，比其小的都扔掉了，然后右边加进来的，如果比出口数数字小，那就进来呗。
- 还有**双端队列**又是什么?我槽？怎么队列成我最陌生的人了。

- 卧槽，stack和queue的实现默认情况下是使用deque实现的。deque是双向队列，两段还可以拓展的，并且deque中的元素并不是严格的连续分。

- 哦~又明白了，这个**单调队列长度是不固定的**，**和窗口是不一样的**，题目中的滑动窗口是一直不变的，我们为了解题维护的队列长度是不一定的，但是一定是严格递减的。

#### 先不写代码，先捋捋这个思路：

刚开始看视频的时候，我认知中的队列只是先进先出的队列，但是这里出现了优先级队列，单调队列，双端队列等一堆吊毛东西。然后清楚了这些定义之后，发现使用deque【双端队列】实现的单调队列，此时的该单调队列是由双端队列实现的，所以能够实现在双端的队首弹出元素的操作。然后根据这个性质构造了一个单调队列。由此解题。









### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

为什么说逆波兰表达式是平时见到的算式的后序遍历呢？恍然大悟！！

平时见到的算式呀`(1+2)*(3+4)`我们在看的时候是中序遍历，我们人类看着舒服，但是机器看懵逼了得。所以机器更喜欢的是后序遍历的形式，他在运行过程也不需要括号，这种形式也就是逆波兰表达式，`12+34+*`机器从头到尾遍历一遍就能得出对应的结果。

那就好整了，看到视频弹幕有个消息发的如果遇到了 1222-怎么判断是122-2还是12-22呢？这个则是过多的担心了，因为，输入的时候是string数组输入的，每个元素都是单独的。

那什么情况下使用栈呢？为什么既然可以看做二叉树是不是可以用递归？二叉树能够解决这个问题吗？

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        //用栈实现的话，碰到符号将前面的数字弹栈处理之后再次压栈。
        //碰到数字直接压栈就行
        stack<long long>st;
        for(int i=0;i<tokens.size();i++){
            if(tokens[i]=="+"||tokens[i]=="-"||tokens[i]=="*"||tokens[i]=="/"){//注意：双引号，因为是字符串，不是字符，字符的话才使用单引号
                //弹栈之后处理
                long long  num1=st.top();
                st.pop();
                long long  num2=st.top();
                st.pop();
                if(tokens[i]=="+") st.push(num1+num2);
                if(tokens[i]=="-") st.push(num2-num1);
                if(tokens[i]=="*") st.push(num2*num1);
                if(tokens[i]=="/") st.push(num2/num1);
            }else{
                st.push(stoll(tokens[i]));
            }
        }
        int result=st.top();
        st.pop();
        return result;
    }
};
```

哈哈可以使用递归的，既然是二叉树形式的，当然使用递归是可以的：

思路：从后向前遍历元素，遇到元素就调用递归函数，遇到符号就使用符号计算下层返回上来的数据。单层计算数据返回值上一级。

递归三部曲：确定参数和返回值，确定递归终止条件，确定单层循环逻辑。

```c++
class Solution {
private:
    int index;
    vector<string> tokens;
    // 递归函数，用于计算逆波兰表达式的值
    long long eval() {
        string token = tokens[index--];
        if (token == "+" || token == "-" || token == "*" || token == "/") {
            long long num1 = eval();
            long long num2 = eval();
            if (token == "+") return num2 + num1;
            if (token == "-") return num2 - num1;
            if (token == "*") return num2 * num1;
            if (token == "/") return num2 / num1;
        }
        return stoll(token);
    }
public:
    int evalRPN(vector<string>& _tokens) {
        tokens = _tokens;//为啥使用类成员变量接收传来的形参呢？因为递归函数要使用，但是递归函数创建的时候没有参数，所以使用类成员变量进行计算
        index = tokens.size() - 1;
        return eval();
    }
};
无参形式的，通过类成员变量共享参数，感觉不够稳定
```

```c++
内存溢出：
class Solution {
private:

    long long eval(vector<string>tokens,int &index){
        string token=tokens[index--];
        //递归终止条件是什么呢？
        // if(index==0)return eval()
        if(token=="+"||token=="-"||token=="*"||token=="/"){
            long long num1=eval(tokens,index);
            long long num2=eval(tokens,index);
            if(token=="+")return num2+num1;
            if(token=="-")return num2-num1;
            if(token=="*")return num2*num1;
            if(token=="/")return num2/num1;
        }
            //碰见数字怎么办呢?又不是栈可以压栈的，作甚呢？
            // 如果是操作数，直接转换为数值返回，这也就 包含了终止条件？因为遍历到最后一定是操作数呀
        return stoll(token); 
        
    };
public:
    int evalRPN(vector<string>& tokens) {
        int index=tokens.size()-1;
        return eval(tokens,index);
    }
};
```

乖乖用栈吧，用例太多了，递归过不了



# 二叉树

## 二叉树part01

二叉树的类型：不完全二叉树，完全二叉树，满二叉树，二叉搜索树，平衡二叉搜索树

**二叉搜索树**是有序的：

若其左子树不为空，则左子树上所有节点数值都小于它的根节点的值

若其右子树不为空，则右子树上所有节点数值都大于它的根节点的值

它的左右子树分别是二叉搜索（排序）树。

**平衡**二叉搜索树：

就是在二叉搜索树的基础上，其左右子树的高度差绝对值不能大于1.

> 二叉搜索树，二叉排序树指的是一种，只是叫的名字不同，平衡二叉树就是在此基础上每个节点的左右子树高度差小于等于1.

### 二叉树的存储方式：

可以使用**数组存储**，也可使用**链式存储**。数组顺序存储的话，怎么遍历？使用下标遍历，链式存储的话，就是使用指针移动访问，更符合我们的直觉。完全二叉树就是堆的存储结构，其存储方式就是数组，之前做过这个heap，一会再回去复习一下。

二叉树的遍历方式：

前中后序遍历和层序遍历。前面三种都是深度搜索，层序遍历相当于广度搜索。

遍历实现的话可以通过递归和迭代法。递归就是重复调用递归函数压到编译器栈中进行处理。迭代法使用的是循环和数据结构栈进行解题。【开发一般不用递归】

前序遍历：

使用递归：

```c++
class Solution {
public:
    void operate(TreeNode*root,vector<int>&vec){
        if(root==nullptr)return ;
        vec.push_back(root->val);
        operate(root->left,vec);
        operate(root->right,vec);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>result;
        operate(root,result);
        return result;
    }
};


```

##### 前序遍历迭代：

```

//使用迭代的话，就是使用循环加栈的结构
    stack<int>st;
    vector<int>result;
    //通过指针进行访问，然后压栈？
    //循环条件是什么？  --为什么其将栈不为空设为循环进入条件？
    while(root!=nullptr){
      result.push(root);
      if(root->left!=nullptr){
            //左不为空，则一直向左访问
            TreeNode* cur=root;

            cur=cur->left;

      }
    }
```



emmm使用迭代的话，我很迷，应该还是根据根左右的顺序进行处理，但是怎么结合栈处理呢。为什么循环条件是栈不为空呢？

看看视频讲解吧。

懂了，将元素放进栈中，然后弹出的时候加入result数组，放进栈的时候要注意，因为栈是先进后出的，所以要实现钟左右的话，我们应该是先将右压入栈中，再将左压入栈中，这样弹栈的时候就先将左孩子放入result了

嗯。。。实现了，

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*>st;//节点指针类型的栈
        vector<int>result;
        if(root==nullptr)return result;//如果为空就返回空的数组
        st.push(root);
        while(!st.empty()){
            //当要左节点的时候一直往里压吗？
            TreeNode *node=st.top();//此时top还是root呢
            result.push_back(node->val);
            st.pop();
            if(node->right)st.push(node->right);
            if(node->left)st.push(node->left);
        }
        return result;
    }
};
```





##### 中序遍历迭代：

思路 ：左边压压压压压，一直压到最下面的叶子结点 else之后保存并弹出一个栈顶元素之后，当前的栈顶元素就是一个叶子节点的根节点，然后再移动指针向右走一次，只走一次哦，唯恐丢失到一个左节点，万一这个右节点还有左孩子那就漏了他的所有的左子树了。

```c++
class Solution {
public:
 
 vector<int> inorderTraversal(TreeNode* root) {
    stack<TreeNode*>st;
    vector<int>result;
   // st.push(root);  --------这个注释掉就可以了
    TreeNode* cur=st.top();
    //左根右记住这个顺序
    while(cur！=nullptr||!st.empty()){// 注意cur不为空也是可以进循环进行操作的
        
        if(cur!=nullptr){
            //左子树疯狂开压
            st.push(cur);
            cur=cur->left;
        }else{//到叶子节点了，开始弹出一次，压一次=右
            result.push_back(st.top()->val);
            st.pop();
            cur=cur->right;  ！！！！！报错空指针了。
        }
    }
    return result;
    }
};
```

空指针了，你猜现在cur在哪呢？

当cur一直压左节点到最后的时候，cur已经是空指针了，在最左边的叶子节点下面，我们要在else的时候调整cur指针，使其恢复可使用的状态。所以else这里应该是

```c++
else{
    cur=st.top();
    result.push_back(cur->val);
    st.pop();
    cur=cur->right;
}
```

一直空指报错是什么原因呢？经过排查发现是第七行的    st.push(root);的原因，不用跟前序遍历一样将根节点先push进栈。

**尝试改变前序遍历迭代：**

我在前序遍历中尝试将那个node节点移动到节点外写为TreeNode* node=root；结果是内存超限制的，因为node在循环没没有更新了。所以while一直进行操作的不变的node. 为什么我要这样做，想仿照中序中的cur，但是中序中的cur是在循环中会变化的。



##### 后序遍历迭代:

重点：在循环中弹出栈中唯一一个数据的时候，会继续向下执行，知道执行到该循环末尾，循环进入条件就像保安，只会在进门的时候管你。其并不是观察者模式。

重点2：注意如果传入是空树，返回值为`vector<int>`返回的是空的`result` ，刚才写半天返回nullptr报错都懵逼了

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
     
        stack<TreeNode*> st;
        vector<int>result;
         if(root==nullptr)return result; //注意这函数的返回值是vector ，刚才写半天返回nullptr报错
        st.push(root);

        while(!st.empty())
        {
            TreeNode*node=st.top();
            result.push_back(node->val);
            st.pop();//先加数组再弹栈，【此时还在循环中，不必考虑是不是弹出后为空了循环就退出了，循环不是观察者模式。。只是大门口保安。】
        
            if(node->left)st.push(node->left);
            if(node->right)st.push(node->right);
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```

调整下压栈顺序，最后result反转之后就是结果。

#### 层序遍历

层序遍历用不了递归，因为其为广度搜索，所以需要其他数据结构辅助输出二叉树节点的值。

这里就用到了队列。队列先进先出，符合一层层遍历的逻辑，而栈先进后出，适合模拟深度优先遍历，也就是递归的逻辑。

**为什么需要借助队列？**

因为二叉树结构如果我们遍历到一个节点，我们无法得知其兄弟节点。图论中的广度优先搜索同样也是依赖队列实现的。

当前层大小的size作为队列大小，不然你都不知道你每次队列要弹出多少个元素，循环弹出元素的时候，循环条件size--

怎么将元素加入队列？-->队列弹出一个节点的时候，将该节点的左右孩子加入到队列。

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*>que;
        vector<vector<int>>result;
        if(root==nullptr)return result;
        que.push(root);//根节点先进队列，队列空的时候意味着已经全部遍历完成了
        while(!que.empty()){
            //不为空的时候才进行后续操作，后续操作是什么？弹出队列首的元素，插入队首元素的孩子，为了完成这个目的，我们需要指针
            TreeNode*temp=que.front();//额。。位置搞错了，temp指针应该在size--的循环中的。
            //还需要一个数组接收一层的数据
            vector<int>vec;
            //还需要确定每层弹出多少个元素
            int size=que.size();//当然第一次层就是一个
            while(size--){
                vec.push_back(temp->val);
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

**整体思路，分解大目标为很多小目标，明确为了实现整体目标的小目标：**

需要借助队列que进行层序处理，需要一个二维数组返回结果result.

然后怎么遍历每层的元素呢？

​		用到二叉树的性质，将某一层所有节点的子节点都加入队列末尾，并从队列中移除这个元素。所以就用到了指针和队列的性质

​		分别是指针用于将队列头的子孩子加入队列末尾。然后逐个pop（）队列中的元素，以实现遍历二叉树的某一层。

那怎么知道要pop多少个呢？就要用到size了。怎么size?

​		要知道上一层pop完之后，下一层的所有元素就已经加到队列中了，所以此时队列的size就是下次循环要pop的次数，所以要巧妙地使用循环结构`while(size--)` 循环中每层需要将数据加到一维数组`vector<int>vec`中，在实现遍历完一层之后将其加入到result中即可，最后返回整个result数组即可。

最终通过捋顺思路之后的代码：

```C
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    queue<TreeNode*>que;
    if(root==nullptr)return result;//剪枝，剪去为空的情况
    que.push(root);//先进队列，让其不为空。
    while(!que.empty()){
        //如果不为空就是将单层数据加进一个一维数组中。两个变量都是为了辅助处理单层的东西
        vector<int>vec;
        int size=que.size();
        while(size--){
            //每层循环要干的事：
            TreeNode* temp=que.front();//队列头整个指针，用于访问孩子和val
            vec.push_back(temp->val);
            que.pop();
            if(temp->left)que.push(temp->left);
            if(temp->right)que.push(temp->right);
        }
        result.push_back(vec);
    }
    return result;
    }
};
```

> 完美，捋顺整体目标，以及拆分每层小目标，为了实现小目标还需要某些变量的支持或者指针的支持，有了这些支持完成小目标，然后各个小目标通过循环，代码顺序或者分支等语句配合，完成整个大目标



#### [层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）



就是翻转一下result返回就可以了。注意需要翻转的是二维数组，每层是什么不用再翻转。

```c++

class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*>que;
        vector<vector<int>>result;
        if(root==nullptr)return result;
        que.push(root);
        while(!que.empty()){
            //不为空的话，就加进来。
            int size=que.size();
            vector<int>vec;
            while(size--){
                TreeNode* temp=que.front();
                vec.push_back(temp->val);
                que.pop();
               if(temp->left) que.push(temp->left);
               if(temp->right)que.push(temp->right);
            }
            // reverse(vec.begin(),vec.end());
            result.push_back(vec);
        }
        reverse(result.begin(),result.end());
        return result;

    }
};
```



#### [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        //单层的最后一个加入数组即可，还是用队列。
        vector<int>result;
        queue<TreeNode*>que;
        if(root==nullptr)return result;
        que.push(root);
        while(!que.empty()){
            int size=que.size();
            while(size--){
                TreeNode*temp= que.front();//还是要用队头指针的，因为依然要将每层元素加入到队列
                que.pop();
                if(size==0){//奶奶的size得等于0的时候才是最后一个，刚开始写的等于1.那是一层元素的队列中倒数第二个了
                     result.push_back(temp->val);
                }
                if(temp->left)que.push(temp->left);
                if(temp->right)que.push(temp->right);
            }
        }
        return result;
    }
};
```



#### [二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

```c++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*>que;
        vector<double>result;
        if(root==nullptr)return result;
        que.push(root);
        while(!que.empty()){
            int size=que.size();
            double chushu=size;
            double sum=0;
            while(size--){
                TreeNode*temp=que.front();
                que.pop();
                sum+=temp->val;
                if(temp->left)que.push(temp->left);
                if(temp->right)que.push(temp->right);
            }
            result.push_back(sum/chushu);
        }
        return result;
    }
};
```



#### [ N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

N叉树啊，每次加入的个数是children的长度。

```c++
感觉写的都不是人话了。
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>>result;
        queue<Node*>que;
        if(root==nullptr)return result;
        que.push(root);
        while(!que.empty()){//这时候再不为空判断就行
            vector<int>vec;

            int size=(que.front()->children).size();
            while(size--){
                Node*temp=que.front();
                que.pop();
                vec.push_back(temp->val);
                for(int i=0;i<(temp->children).size();i++){
                  que.push(temp->children[i]);
                };
            }
            result.push_back(vec);
        }
        return result;
    }
};
```



emmmm..看完解析发现没有太大的问题，主要就是加入队列的时候，加的有点问题。和之前的层序相比，将val放入的vec的过程是不变的，只是将元素推进队列的时候推的方法需要for循环推。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>>result;
        queue<Node*>que;
        if(root==nullptr)return result;
        que.push(root);
        while(!que.empty()){//这时候再不为空判断就行
            vector<int>vec;

            int size=que.size();
            while(size--){
                Node*temp=que.front();
                que.pop();
                vec.push_back(temp->val);
                // for(int i=0;i<(temp->children).size();i++){
                //   que.push(temp->children[i]);
                // };
                for(Node* child:temp->children){
                    que.push(child);
                }
            }
            result.push_back(vec);
        }
        return result;
    }
};
```







## 二叉树part02



#### 翻转二叉树

```c++
class Solution {
public:
    TreeNode* reverseTree(TreeNode* root){
        if(root==nullptr)return nullptr;
        TreeNode*temp=new TreeNode();
        temp=root->left;
        root->left=root->right;
        root->right=temp;
        // if(root->left) return reverseTree(root->left);
        // if(root->right)return reverseTree(root->right); 
        //*left=reverseTree(root->left);
        //*right=reverseTree(root->right);
       reverseTree(root->left);
       reverseTree(root->right);
       return root;

    };
    TreeNode* invertTree(TreeNode* root) {
        return reverseTree(root);
    }
};
```

两种注释掉的处理左右孩子的方式为什么有问题呢？

第一种 ：

​	if之后直接return  你要干啥，处理左孩子之后直接return 怎么？右孩子不处理了？ 而且

第二种：

​	没有意义的赋值，不清晰的处理，以为在单层循环处理了左右孩子，其实并没有处理左右孩子的逻辑，永远都是处理单层的逻辑，**只是需要将逻辑向下递，根为左孩子的具体逻辑，就要到他的那层他去处理了。我在这层只需要给他扔下去即可，**所以调用递归函数传入参数root->left或者root->right.



哦~递归函数是可以没有返回值的，反正我也不理解这里又返回值有什么意义，好像就是没意义。

```c++
class Solution {
public:
    void  reverseTree(TreeNode* root){
        if(root==nullptr)return ;
        TreeNode*temp=new TreeNode();
        temp=root->left;
        root->left=root->right;
        root->right=temp;
        reverseTree(root->left);
        reverseTree(root->right);
    };
    TreeNode* invertTree(TreeNode* root) {
      reverseTree(root);
      return root;
    }
};
```

迭代法，使用栈的方式：

```c++
class Solution {
public:

    TreeNode* invertTree(TreeNode* root) {
        //迭代也是根左右，但是需要使用的数据结构栈
        stack<TreeNode*>st;
        if(root==nullptr)return nullptr;
        st.push(root);
        while(!st.empty()){
            TreeNode*temp=st.top();
            swap(temp->left,temp->right);
            st.pop();
            if(temp->left)st.push(temp->left);
            if(temp->right)st.push(temp->right);
        }
        return root;
    }
};
```

使用队列：

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //迭代层序遍历进行翻转
        queue<TreeNode*>que;
        if(root==nullptr)return nullptr;
        que.push(root);
        while(!que.empty()){
            int size=que.size();
            while(size--){
                TreeNode*temp=que.front();
                swap(temp->left,temp->right);
                que.pop();
                if(temp->left) que.push(temp->left);
                if(temp->right) que.push(temp->right);
            }
        }
        return root;
    }
};
```

#### 对称二叉树

```c++
class Solution {
public:
    //返回值是什么？只知道应该参数是两ge
    bool judge(TreeNode* m,TreeNode* n){
       if(m==nullptr&&n!=nullptr)return false;
       else if(m!=nullptr&&n==nullptr)return false;
       else if(m==nullptr&&n==nullptr)return true;
       else if(m->val!=n->val)return false;
       bool outside=judge(m->left,n->right);
       bool inside=judge(m->right,n->left);
       return outside&&inside;
    }
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr)return true;
        return judge(root->left,root->right);
    }
};
```

迭代怎么写呢？

​	如果使用**队列**的话：

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*>que;
        if(root==nullptr)return true;
        que.push(root->left);
        que.push(root->right);
        while(!que.empty()){
            TreeNode*m=que.front();
            que.pop();
            TreeNode*n=que.front();
            que.pop();
            if(m==nullptr&&n==nullptr) continue;//左的左，右的右同时为空，就是返回true
            if(m==nullptr||n==nullptr||m->val!=n->val){return false;};
            que.push(m->left);
            que.push(n->right);
            que.push(m->right);
            que.push(n->left);
        }
        return true;
    }
};
```

#### 二叉树的最大深度

跟哄小孩的题一样：

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};

-----------
class Solution {
public:
    int returnDepth(TreeNode* root){
        if(root==nullptr)return 0;
        int left=returnDepth(root->left);
        int right=returnDepth(root->right);
        int depth=1+max(left,right);
        return depth;
    }
    int maxDepth(TreeNode* root) {
        return returnDepth(root);
    }
};
```

用的后序遍历，其实使用后序遍历的话求的是二叉树的高度，因为是从树底为0慢慢加到根的嘛，但是树的深度和高度是一样的数值，在这里就用树的高度代替为树的深度了，这里提醒一下。如果要实实在在求树的深度应该是前序遍历的方法，<u>根左右的去做</u>，这才是从root向下去延伸求深度。



##### 迭代：

我草，，，我迭代傻逼了，我用的栈迭代，一看求深度或者高度应该用队列，为啥我想着用栈呢？

深搜越求越深，所以想用栈。。。。被字面迷惑了，其实还是层序抛完求多少层。

而且我栈还搞错了

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
      stack<TreeNode*>st;
      st.push(root);
      int count=0;
      while(!st.empty()){
            TreeNode*temp=st.top();
            st.pop();
            if(temp->left&&temp->right)
            st.push(temp->left);
            st.push(temp->right);
            count++;
            if(temp->left&&!temp->right)st.push(temp->left);count++;
            if(temp->right&&!temp->left)st.push(temp->right);count++;
      }
      return count;
    }
};
```



深度为啥用队列呢？每层元素完全抛出队列之后就增加一层深度？

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        queue<TreeNode*>que;
        que.push(root);
        int depth=1;
        while(!que.empty()){//不为空的时候退出循环
            //需要什么？指针
            TreeNode*temp=que.front();
            int size=que.size();
            depth++;
            for(int i=0;i<size;i++)
            {
                que.pop();
                if(temp->left)que.push(temp->left);
                if(temp->right)que.push(temp->right);
            }
        }
        return depth;
    }
};
```

ennnnn为什么会报错，是不是因为指针创建的位置不对，应该创建在for循环中，但是又为什么创建在for循环中呢？

因为for作用是 ：处理当前层所有节点，处理当前层所有节点意味着，此时获取队首元素就是当前层左边第一个节点，所以才在for循环的时候获取队首节点

嗯，这就是为啥获取队首的指针在for循环内。

```c
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)return 0;
        queue<TreeNode*>que;
        que.push(root);
        int depth=0;
        while(!que.empty()){//不为空的时候退出循环
            int size=que.size();//当前层节点数量
            depth++;//处理完一层之后深度加1

            //处理该层节点
            for(int i=0;i<size;i++)
            {
                TreeNode* temp=que.front();
                que.pop();
                if(temp->left)que.push(temp->left);
                if(temp->right)que.push(temp->right);
            }
        }
        return depth;
    }
};
```

## 二叉树part03

#### 平衡二叉树

递归:

递归函数返回值应该是什么，这个好想，int类型返回高度嘛，但是如果此时的根节点的做优子树已经不是平衡二叉树了应该怎么标记呢？<u>那就要使用特殊数字了，-1</u>，这是个好思路。

终止条件： 就是如果节点为空，返回的应该就是0，到低了

递归逻辑：判断左右子树的高度，相减是否大于等于1，大于1则返回-1.否则返回最大树高+1.

```C
class Solution {
public:
    int getHeight(TreeNode* root){
        if(root==nullptr)return 0;

        int leftHeight=getHeight(root->left);
        //还要做判断，左右子树返回上来的是不是-1
        if(leftHeight==-1)return -1;
        int rightHeight=getHeight(root->right);
        if(rightHeight==-1)return -1;

        if(abs(leftHeight-rightHeight)>1){
            return -1;
        }else{
            return 1+max(leftHeight,rightHeight);
        }    
    } 
    bool isBalanced(TreeNode* root) {
        //主函数怎么写呢？直接调用递归函数，递归函数最终返回上来的是什么，是不是要进行比较判断主函数返回true还是false
    
         return getHeight(root) == -1 ? false : true;
    }
};
```

起初是有错误之处的 ，因为在判断是不是左子树或者右子树返回的是否为-1的时候，我将其leftHeight和rightHeight都赋值成-1了。这没有意义，如果有-1的话，应该直接返回-1.不用再做后续判断什么的了【-1就是代表了子树为非平衡二叉树，那么整棵树也是非平衡二叉树了】

#### 二叉树的所有路径

到叶子结点的时候才将该路径加到结果集中。

注意递归函数中调用自身的时候，由于递归的特性，所以不会在执行一行递归代码之后立即执行下一行代码，而是知道递归函数有返回值，才会执行下一行代码，这里看pop_back作为回溯的时候，整的我很迷糊，但是更深的理解了递归代码的这种知道最后返回上来才会执行当层的下一行函数的特性。

```c++
#include<vector>
#include<string>
#include<iostream>
using namespace std;    
 struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
void Solute(TreeNode* cur,vector<int>& path,vector<string>&result){
   path.push_back(cur->val);
   if(cur->left==nullptr&&cur->right==nullptr){
       string SPath;
       for(int i=0;i<path.size()-1;i++){
           SPath+=to_string(path[i]);
           SPath+="->";
       }
       SPath+=to_string(path[path.size()-1]);
       result.push_back(SPath);
       return ;
   } ;//到叶子结点的时候停止，返回路径
   if(cur->left){
       Solute(cur->left,path,result);//遇到递归函数要注意，不会立即执行下一行代码，而是要等到递归函数返回之后才会执行下一行代码
       path.pop_back();//回溯，但是上面的递归函数直到遇到叶子结点才会返回，不要搞乱了每层的递归
   }
   if(cur->right){
       Solute(cur->right,path,result);
       path.pop_back();
   }
}
   vector<string> binaryTreePaths(TreeNode* root) {
       vector<int>path;
       vector<string>result;
       Solute(root,path,result);
       return result;
   }
};
int main(){
    // 创建测试用的二叉树
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->right = new TreeNode(5);
    
    // 创建Solution对象并测试
    Solution solution;
    vector<string> paths = solution.binaryTreePaths(root);
    
    // 输出所有路径
    cout << "二叉树的所有路径：" << endl;
    for(const string& path : paths) {
        cout << path << endl;
    }
    
    // 释放内存
    delete root->left->right;
    delete root->left;
    delete root->right;
    delete root;
    
    return 0;
}
```

#### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

```c++
class Solution {
public:
int getLeft(TreeNode* node){
    if(node==nullptr)return 0;
    int left= getLeft(node->left);
    if(node->left&&!node->left->left&&!node->left->right){
        left=node->left->val;
    }
    int right=getLeft(node->right);
    int result=left+right;
    return result;
}
    int sumOfLeftLeaves(TreeNode* root) {
        //左右根吗？
        return getLeft(root);
    }
};
```





## 二叉树part04 

#### [找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

使用层序遍历的话，就是记录一些每层的第一个元素就行，因为这样虽然会每层都刷新这个值，但是到最后一层的时候就不会被刷新了，返回这个值就行。

使用层序遍历

```C++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*>que;
        if(root!=nullptr)que.push(root);
        int result=0;
        while(!que.empty()){
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode*temp=que.front();
                if(i==0)result=temp->val;
                que.pop();
                if(temp->left)que.push(temp->left);
                if(temp->right)que.push(temp->right);

            }
        }
        return result;
    }
};
```

emmmm。。。虽然写了很多遍了，但是每层for循环中做的什么总是会搞混

- 比如temp指针的创建，就是进入for循环的时候一层就是一轮嘛，这一层的第一个元素就是que.front()也就在这里创建一个指针开始pop（），push等操作。
- 然后就是循环中，循环到第几个的问题：直接i==x就行，因为这不是数组非要写成`a[i]`这种形式干什么。仅仅是个循环，所以如果需要第几个直接就i==第几个就可以了。

-----

嗯，有更天才的想法，从右向左层次遍历，最后一个出来的必定是最左边的那个元素的值。甚至不需要每层for循环，只用不断更新result就行

```C
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*>que;
        if(root!=nullptr)que.push(root);
        int result=0;
        while(!que.empty()){
                TreeNode*temp=que.front();
                result=temp->val;
                que.pop(); 
                if(temp->right)que.push(temp->right);
                if(temp->left)que.push(temp->left);
        }
        return result;
    }
};
```



#### 路径总和

我的思路是返回值为int ,为什么为int ,从最低端返回到根的时候，这个返回的int怎么处理呢？一直累加?到根的时候再判断是不是为targat。但是递归的话，还是递归理解的不够深刻吗？

这里递归函数初始值的话，我们需要传入0.然后向下逐层加val。

终止条件，若节点为空，返回int_min 。表示此路不通。

到达叶子节点的时候，检查累加和是不是等于target，如果是，返回累加和，表示找到了路径‘

如果检查累加和不等于target，返回INT_MIN，表示此路径不符和条件。

递归搜索：

先递归左子树，获取返回值leftRes；

如果leftRes!=INT_MIN.说明左子树找到了目标路径，。如果左子树未找到再递归右子树，返回右子树结果right

状态转换：任何子树中找到了目标路径，都会层层递归返回该路径和，

所有路径都不符合条件，最终则会返回INT_MIN。



```c++
class Solution {
public:
    int target;
    int allSum(TreeNode* node, int currentSum) {
        if (node == nullptr)
            return INT_MIN;

        currentSum += node->val;

        if (node->left == nullptr && node->right == nullptr) {
            return currentSum == target ? currentSum : INT_MIN;
        }

        int leftRes = allSum(node->left, currentSum);
        if (leftRes != INT_MIN)//这里是判断返回值是否为INT_MIN，假如为叶子结点父节点，此时这个父节点到左叶子的累加就不等于target，所以在递归完成之后处理一下，如果返回的是INT_MIN，那就还需要递归判断该节点右孩子是否符合。、、所以这里左递归之后可以通过值是否等于某个条件可以开启右递归。很神奇。但是我不知道怎么总结。这属于对递归结构的掌握吗？就是return了的话，递归就被终结了，甚至可以通过某些返回条件开启或者关闭后续是否需要继续递归。
            return leftRes;
        int rightRes = allSum(node->right, currentSum);
        return rightRes;
    };
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr)
            return false;
        target = targetSum;
        return allSum(root, 0) == targetSum ? true : false;
    }
};
```

看到代码中那段长长的注释了嘛？那就是对高级递归的理解，使用return短路递归，控制1递归流程。

##### 递归短路/递归剪枝

这种递归的本质：带短路的深度优先搜索

这种现象可以总结为：

- 递归中的条件短路：通过检查递归返回值是否满足某些特定条件（这里是left!=INT_MIN)，决定是否向后递归.

- 状态传递与剪枝：递归返回值，不仅携带有路径信息（路径和），还充当了搜索标识，即是否搜索到目标路径。搜索到目标路径的话，就中止其他分支的搜索。本题中暗含的意思就是if(left==INT_MIN)的时候【咱没搜索到啊】继续向后执行右递归，右递归如果执行到最后也没搜到，那就也是返回INT_MIN，继续向上返回。也就是上级节点又满足了INT_MIN，继续右递归。

  ###### 这种设计属于「递归结构的高级应用」

对于递归过程的精确控制，主要体现在：

1. 递归的双重语义：
   1. 返回INT_MIN。表示此路径无效，继续搜索其他路径
   2. 返回目标和，表示，已找到解。也就是退出本次递归之后，向下执行代码，符合了if(LeftRes！=INT_MIN)，直接return 退出函数。
2. 提起那中止机制
   1. 左子树返回非INT_MIN的时候，直接返回结果，跳过右子树递归。
   2. 剪枝大大减少不必要的计算。
3. 状态回溯
   1. 递归返回的时候，自动回溯到上一层状态。【是啊，递归返回的时候直接回溯到上一层了】，但是Current

- **`currentSum`的修改是局部的**：每个递归层的`currentSum`都是独立的副本，修改不会影响上层。
- **递归返回时自动恢复状态**：无需手动回溯`currentSum`，因为值传递机制已经保证了状态隔离。

```C
class Solution {
public:
    int target;
    int allSum(TreeNode* node, int currentSum) {
        if(node==nullptr)return INT_MIN;
        currentSum+=node->val;
        if(node->left==nullptr&&node->right==nullptr){
            return currentSum==target?currentSum:INT_MIN;
            //叶子节点是不是等于目标结果，若是，则返回当前值，如果不是，返回INT_MIN，用于父节点的继续递归
        }
        int leftRes=allSum(node->left,currentSum);
        if(leftRes!=INT_MIN)return leftRes;//不等于int_MIN就是找到了嘛，直接返回就行了

        //但是呢，如果没找到还得继续右递归
        int rightRes=allSum(node->right,currentSum);
        return rightRes;//成功就返回值，不成功就向上层返回INT_MIN.到此算是中左右都处理了。

    };
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr)
            return false;
        target = targetSum;
        return allSum(root, 0) == targetSum ? true : false;
    }
};
```

然后再来个返回值为bool类型的。

```c++
class Solution {
public:
    bool allSum(TreeNode* node, int currentSum) {
        if(node==nullptr)return false;
        //到叶子节点的时候，返回
        currentSum-=node->val;
        if(node->left==nullptr&&node->right==nullptr){
            return currentSum==0;
        }
        //左右递归
        // if(node->left) return allSum(node->left);  // 错误：可能跳过右子树
        // if(node->right) return allSum(node->right); // 可能永远执行不到
        //这里不可以直接返回，因为直接返回的话，没办法回溯递归处理右子树了。    
        bool leftRes=allSum(node->left,currentSum);
        if(leftRes) return true;
        return allSum(node->right,currentSum);   
    };
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)return false;
        return allSum(root,targetSum);
    }
};
```

```C
  if(node->left) return allSum(node->left);  // 错误：可能跳过右子树
 if(node->right) return allSum(node->right); // 可能永远执行不到
```

如果这样写是一定错了的，搜完左子树不管咋样都return了，右子树还咋办呢？

##### 显式回溯

嗯，递归归的过程就是隐式回溯，但是如果在递归调用之前对数值进行处理的话，那么需要显式回溯：

```Cpp
class Solution {
private:
    bool traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) return true; // 遇到叶子节点，并且计数为0
        if (!cur->left && !cur->right) return false; // 遇到叶子节点直接返回

        if (cur->left) { // 左
            count -= cur->left->val; // 递归调用前对输入值进行处理，处理节点;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val; // 回溯，该值因为被提前处理，所以如果执行到这里是需要显式回溯 撤销处理结果的
        }
        if (cur->right) { // 右
            count -= cur->right->val; // 递归，处理节点;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val; // 回溯，撤销处理结果
        }
        return false;
    }

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        return traversal(root, sum - root->val);
    }
};
```



#### 路径总和2:

因为要找出所有值等于target的路径，所以要遍历整颗二叉树，要遍历整颗二叉树的话，递归函数就不要有返回值。



使用递归的时候需要对值和加进数组的对象进行回溯。

#### 中序后序构造二叉树

先从后序看，后序最后一个是根，然后根据这个信息切中序，得到中序的左右子树之后再去后序中对照看，两个子树的最右边的元素依旧是根，然后再到俩子树中去切。

嗯嗯，然后一层层递归切下去。

切分数组就要保证有一个循环不变量，这样在后续处理中才能标准化处理每一层的数据。

开始实现递归代码：

1. 递归参数和返回值。参数是两个数组，中序和后序的数组，返回值是构成的二叉树的根节点
2. 递归的终止条件：  后序数组为空的时候，也就说明整完了都，所以可以结束了
3. 单层递归处理逻辑：
   - 这里面东西可多了吧
     - 切割中序遍历的数组，切后续遍历的数组，然后还要创建节点，用于添加到构建的树上。
     - 怎么选择切割点？切割点是什么？是后续数组的一个元素，所以是postOrder[postOrder.size()-1].
     - 切完中序切后序，怎么切后序呢？我们知道中序中的两个区间的大小了，就可以根据区间大小，在后序数组中去切割了，切完之后每个小区间的在最后一个元素都是子树的根节点。这里需要代码处理一下，当后序遍历中长度为1的时候，就可以直接return，长度为1的时属于叶子结点了。
   - 也就是后序数组中的最后一个元素切中序数组，中序数组的子序列大小切后序数组。
     - 那切割顺序呢？当然是先切中序，再切后续啦。我们从后序中获取一个根节点，然后开切。
   - 那怎么构建二叉树呢？就是通过递归构建了 root->left=递归函数（左中序，左后序）
   - root->right=递归函数（右中序，右后序）



> 切割中的小妙招，将index定义在外，然后for循环的时候将，index++，遇到某些情况的时候，直接break,这样在处理的时候，0--(index-1)是左子树，（index+1）--最后一个是右子树的vector

这里切的时候左闭右开还是左闭右闭，就是说的切分为两个数组时候怎么表示

9 3 15 20 7 根为3的时候，一切就是`[9，index),[index+1,inOrder.end())` 嗯，左闭右开

```c
整理下思路就是
    递归函数
    首先处理终止条件：后序数组为空的时候return root；为什么不是中序为空？
    创建node,创建节点，用于构建二叉树呀。
    然后后续数组长度为1时返回root
    （创建node,用于返回，所以应该创建是在获取数组长度之前）
    然后根据后序遍历获取根节点，起作用是用于切割中序数组的
    切割中序数组
    切割后序数组
    
    递归处理node->left和node->right 用于构建二叉树。所以这里是递归构建二叉树。
    node->left=递归函数（左中序，左后序）
    node->right=递归函数（右中序，右后序）
    return root；
```

