## 字符串总结：

有需要翻转操作的有三种选择，使用库函数reverse，自建reverse函数以及，直接在主函数中使用双指针对夹进行处理翻转。

三刷[翻转字符串2](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)  .尼玛没想到双指针居然，大意了。

```c++
狗屎一样的做法，但是总结出来了很多，值了

class Solution {
public:
    string reverseStr(string s, int k) {
        //思路呢？每2k个字符翻转前k个，记得处理最后x<k以及k<x<2k的情况。题解中的方法很巧妙
        //处理字符串首先得遍历吧
        int n=s.size();
        for(int i=0;i<n;i++){
            //每2k个进行翻转
            if(i%(2*k)==0){//满足到2k个条件的时候
            //1.翻转前k个,怎么翻转？ w2:怎么使用min? w3：看解析使用的双指针，为啥呢？突然好想能够总结出一点，翻转的话，最好使用while配合双指针进行互相逼近，然后进行翻转操作
            while(k/2--){
                swap(s[i-2k+1],s[i-k])
                //....循环条件不对劲，对夹没有。k一大的话，只翻转了一次。
            }
            }
        }
    }
};
```

还是有些问题没理解透彻：

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
       int n=s.size();
        for(int i=0;i<n;i+=(2*k)){//初始化i;i的取值范围，单次循环结束之后对i的处理方式
            //每次转移2k个位置。
        int slow=i;
        int fast=min(i+k-1,n-1);//fast要注意了，处理最后的时候得小心
        while(slow<fast){
            swap(s[slow],s[fast]);
            slow++;
            fast--;
        }
    //结束的时候记得更新slow的位置，不然每次进for循环slow都是0
    //slow=i-2k-1.   //不对劲，这个处理没有任何意义。下次进入循环还是slow=0；我搞混了每次进入循环时后slow和fast相对本次循环的位置。
        }
        return s;
    }
};

1. 比如要考虑指针的创建时机，在循环外部还是内部，外层循环还是内层循环。
    
2. 理解好创建单层循环的意义，以及单层循环处理的是什么。不要将内外层循环处理的内容搞混
    
3. for循环的最后一个参数意义，是一次循环结束之后，定义的i的处理方式
```

库函数reverse使用：

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        //  使用库函数reverse翻转 其参数应该是迭代器
        for (int i = 0; i < s.size(); i += (2 * k)) {
            if (i + k < s.size()) {
                reverse(i + s.begin(), i + k + s.begin());
            } else {
                reverse(i + s.begin(), s.end());
            }
        }
        return s;
    }
};
```







刷题过程问题总结：

问题1：翻转前k个,怎么翻转？ 

- 使用双指针或者reverse库函数啊，man呆。

问题2：最后那段怎么使用min处理呢？

- 巧妙地使用min，但是注意min处理的是fast指针诶。处理的话，应该注重每次循环的通用性以及最后一次的特殊性。

- 这里fast指针使用min，`min(i+k-1,n-1)`,循环的最后一次用不用全部翻转，或者只用翻转前k个。i+k-1是下标。n-1也是。

问题3：你踏马怎么每次i只移动一个距离？每次一个距离性能开销有点高啊？

- 直接移动`2*k`,循环条件中表示也就是`i+=2*k`.   甲霸。









问题4：为啥使用双指针？我应该统计下双指针的使用场景了

## 双指针总结篇

基本用法就两种吧：快慢指针，对夹指针 重要的是指针移动逻辑

**数组中**，移除元素，for循环条件定义一个快指针进行逐个移动，定义一个慢指针，满足条件时候移动（不等于target）,等于target的时候只有快指针移动，这样慢指针就会在移动过程中覆盖掉等于target的元素。使用双指针优势就是将时间复杂度为O(n2)降为O(n).

**字符串篇**，翻转元素，[替换元素](https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html)，通过将空格替换成其他元素，从后向前填充元素使用双指针。

**哈希表篇**,三数之和通过双指针对夹，四数之和通过两层for循环依旧是双指针对夹，最终找出所有符合条件的数组。两数之和可以用哈希表法，**但是也可以用双指针**。

**链表篇**，还未进行二刷，[环形链表](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)是否有环以及出口问题。



# 栈、队列

C++中Stack是容器吗？

栈、队列和STL之间的关系是什么？

- 栈和队列是STL（C++标准库）里面的两个数据结构。

我们使用的Stack STL属于哪个版本？

SGI STL ，其被Linux的C++编译器GCC所采用，SGISTL其为开源软件，可读性很高



栈提供push，pop等接口，所有元素必须符合先进先出，所以栈不提供走访功能，也不提供迭代器（iterator）。不像map，set等提供迭代器用于遍历所有元素。

所以STL中的**栈不被归类为容器**，而被归类为容器适配器 container adapter 

**栈的底层**实现可以是vector,deque,list 。主要就是数组和链表的底层实现，我们常用的STL，如果没有指定底层的话，默认是使用deque作为底层结构的。deque：双端队列，封住一端只开通另一端就是栈了

我草可以指定底层实现结构，方法如下：

```C
std::stack<int,std::vector<int>>third;使用vector作为底层容器的栈
```

队列和栈基本是一样的！！

队列是先进先出的数据结构，同样不允许有遍历行为，不提供迭代器，SGI STL中队列一样是以deque为默认情况下的底层数据结构。

可以指定list为底层实现，初始化语句如下：

```c++
std::queue<int,list<int>>third;定义以list为底层容器的队列
```

同样队列也不被归类为容器，而是容器适配器 container adapter 

### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

栈实现队列？第一次遇到。怎么做呢?

思路：构造函数怎么写呢？既然是使用栈实现队列了，构造的时候应该是使用两个栈进行初始化哈。初始化完成之后再进行其他函数的实现。

起初在疑惑为什么用两个栈实现呢?一个栈直接进完元素就出不就行了，乍一想没什么问题，但是不允许连续进多个元素呀。所以一个栈是没办法实现的。

所以题目要求使用两个栈，栈1栈2，用于解题，两个栈依旧想不出怎么使用，看了视频才知道。栈1中元素逐渐弹出添加到另一个栈中，栈2再弹出，此时的元素的出栈顺序就是和进栈相同了。

--注意栈1中元素1出栈的时候必须出完，不然会打乱整个的顺序 

也就是当栈2不为空的时候，如果要出队列操作，直接从栈2中弹出就行，只有当栈2在某一次弹出操作变空之后才会将栈1中所有元素直接加到栈2。【】

进队列操作的话：就是直接往栈1中加即可。

peek函数： int result=stackOut.top();这里不能直接从stackout中获取栈顶元素作为整个队列的首元素，因为stackout栈可能为空，还得从stackIn中转移到stackOut中，这个操作逻辑在pop函数中写过了，所以可以复用pop函数。



```c++
class MyQueue {
public:
    stack<int>stackIn;
    stack<int>stackOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stackIn.push(x);
    }
    x
    int pop() {
        if(stackOut.empty()){
            while(!stackIn.empty()){
                stackOut.push(stackIn.top());
                stackIn.pop();
            }
        }
        int result=stackOut.top();
        stackOut.pop();
        return result;
    }
    
    int peek() {
       int result= this->pop();
       stackOut.push(result);
       //因为要的是栈2的栈顶元素，所以先弹出获取，然后再把这个元素放回栈2，有借有还，完美
       return result;
//        int result=stackOut.top();这里不能直接从stackout中获取栈顶元素，因为stackout栈可能为空，还得从stackIn中转移到stackOut中，这个操作逻辑在pop函数中写过了，所以可以复用pop函数。

    }
    
    bool empty() {
        if(stackIn.empty()&&stackOut.empty()){
            return true;
        }else{return false;};
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

queue的一些成员函数：

默认构造函数 ：queue();创建空队列

拷贝构造函数：queue（const queue&other) 通过复制另一个other队列来创建新队列

##### 元素访问：

- `front()`:返回队列中第一个元素的引用。若队列为空，则调用此函数会导致未定义行为。

- **`back()`**：返回队列中最后一个元素的引用。若队列为空，调用此函数会导致未定义行为。

##### 容量：

`empty()`：判断队列是否为空。空则返回true，否则返回false

`size()`:face_with_head_bandage:返回队列中数组元素。

##### :rocket:修改器：

push (const value_type&value):队列尾部插入新元素，值为value

`pop()`：:yum:移除队列中的第一个元素，**没有返回值**

`emplace`:队列尾部就地构造一个新元素，**没有返回值**



```c++
    int pop() {
        //弹出的时候先统计size吧,然后
       int n= QQ.size();
       while(n--){
            int result=QQ.pop();
            QQ.push(result);//得用front front 才有返回值，直接添加到队末
       }
       int E_result=QQ.pop();  //pop()没有返回值
       return E_result;
    }
```

这里就是为了实现功能，但是没掌握库函数的具体用法，是否有返回值等

```c++
class MyStack {
public:
    queue<int>QQ;
    MyStack() {
        
    }
    
    void push(int x) {
        QQ.push(x);
    }
    
    int pop() {
        //弹出的时候先统计size吧,然后
       int n= QQ.size();
       n--;//让循环运行n-1次。最后一个元素也就到了队列首
       while(n--){
            QQ.push(QQ.front());
            QQ.pop();
       }
       int E_result=QQ.front();
       QQ.pop();
       return E_result;
    }
    
    int top() {
        int n=QQ.size();
        n--;
        while(n--){
            QQ.push(QQ.front());
            QQ.pop();
        }
        int result=QQ.front();
        QQ.push(QQ.front());
        QQ.pop();
        return result;
    }
    
    bool empty() {
        return QQ.empty();
    }
};

```

