# vector

既然是动态数组，和静态数组的区别是什么？

为什么是动态数组呢？动态表现在哪里？

动态意味着其可以扩展数组的大小，动态扩容机制是什么？

扩容根据重置后的大小找一块内存空间，然后将之前的数据放在这块内存中。



说到STL，那就有一些通用的关键字：

begin 

end 

size：vector数组中元素的个数

 capaicity: vector的实际内存

erase删除vector中元素 ，参数为迭代器，删除一个元素之后，该元素后面的元素会向前一位，其他数据结构也有重载这个函数，但是性质不同的话，操作原理也不同，比如是链表的话后面的元素就不会都向前移动一位。

push_back向数组末尾放置元素。在其他位置构造之后，然后放入数组中时使用，或者是复制来的一个对象，然后放置在数组中

哎呦想起来还有个emplace_back,这个是直接在数组末尾构造一个元素是吧。是的，也是在末尾，记得如果初始化动态数组时候分配了一定的位置个数，则会在这几个后面进行添加新emplace_back的元素。

### algorithm中的函数find

**find 查找vector中元素位置** 嗯，这个我是真不会用，我以为直接"对象名.find()",这个参数有三个，起止位置以及要查找的元素信息，。返回的是个迭代器，指向查找到的第一个元素

find函数会借助 `==` 运算符来判定两个对象是否相等。

**在自定义对象使用STL容器的时候需要进行一些运算符重载。**

比如在我的代码中，我使用find函数发现并没有起作用。

```c++
#include <vector>
#include <iostream>
#include<string>
using namespace std;

struct dx1{
    int age;
    string name;
    dx1(){};
    dx1(int age,string name):age(age),name(name){cout<<"调用含参构造函数："<<name<<" | "<<age<<endl;};
};
int main(){
    vector<dx1>dxi;
    dxi.emplace_back(dx1(15,"ee"));
    dxi.emplace_back(dx1(16,"bb"));
    dxi.emplace_back(dx1(19,"cc"));

    for(auto i:dxi ){
        cout<<"age:"<<i.age<<"name:"<<i.name<<endl;
    }
    // vector<dx1>::iterator 
     auto it2 =find(dxi.begin(),dxi.end(),(16,"bb")); 报错！！原因--这是algorithm头文件中的函数
     //这边没办法找到与这个相同的元素，因为没有运算符重载，这是因为 find 函数会借助 == 运算符来判定两个对象是否相等。
    cout<<"find到的内容："<<it2->age<<it2->name<<endl;

     vector<dx1>::iterator  it3 =find(dxi.begin(),dxi.end(),(19,"bb"));
     cout<<"find到的内容："<<it3->age<<it3->name<<endl;
return 0;
}
```



#### 解决：

哈哈，find函数是algorithm中的函数，不是STL中的函数，为啥使用find函数报错，就是因为没有加上头文件，笑闷了。





移动构造和移动赋值运算符重载中

### 为什么要有`if(this!=&other)`

在移动赋值运算符重载函数中添加 `if (this != &other)` 条件判断主要是为了避免自我赋值（self-assignment）的情况。

#### 自我赋值导致的后果：

当发生自我赋值时，other和*this会指向同一个对象，然后执行移动语义的时候，std::move会将自身资源所有权转移走，并且清空other.name,也就是清空了this->name,这就导致了对象丢失原本持有的资源。最终结果就是该对象处于不合法的状态。



移动赋值运算符重载函数" = "几个容易遗忘的地方：

1. 返回值类型为引用类型，最后记得返回*this. 参数为右值，需要&&
2. 函数使用noexcept能够在使用容器时提高效率
3. 判断自赋值
4. 移动赋值时的操作。直接move

### 迭代器更新

迭代器相关知识，当容器内元素变化时，迭代器可能会失效然后重新指向新的位置，这种变化是怎么实现的呢？

维护指针。比如erase操作，删除一个元素之后，后面的元素同时向前一位，移动完成之后对指向末尾的指针进行操作，对指针执行自减操作，然后销毁最后一个元素（因为已经向前移动了）。

# 数组

## part01:

### 二分法

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
      int left=0;
      int right=nums.size()-1;//都是下标呗

      while(left<=right){//左闭右闭，middle的不同
        int middle=(left+right)/2;
            if(nums[middle]>target){//说明比target大，那就将右边的向左收紧
                right=middle-1;//为什么要减1，因为此时是大于Target的，当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
            }else if(nums[middle]<target){
                left=middle+1;
            }else{
                return middle;
            }
      }
    return -1;
    }

};

```



1. 重要的地方，每次循环的区间定义。也就是所说的“循环不变量”，这个“不变量”就是每轮循环的区间定义是不变的。也就是边界处理的时候，我们始终要根据这个不变的区间做边界处理。

2. 循环或者分支的进入条件是否满足，满足才会进入该循环或者该分支。

3. middle是否可以当做边界，当left<=right的时候，

   - 假如此时nums[middle]>target 也就是对right要赋值了
     -  nums[middle]此时绝对不会等于target了
     -  循环中会处理right==left的情况
   
   - 根绝这两个条件所以可以放心的将right=middle-1;  
   - 假如nums[middle]<target.  left要进行变换，那么left怎么变？
     - nums[left]没有可能等于target了。
     - nums[left]在循环中会处理和nums[right]相等的情况。

   - 根据这两个条件，left可以放心=middle+1;
   
   总结就是是否此时下标为middle的元素是否参与下次判断，若不参与且在下次循环中的处理会覆盖掉这个值相邻的元素，则可以放心的进行处理

也就是确保能够全覆盖所有可能得条件



----

二分法的核心要点在于维护 “循环不变量”，也就是每轮循环的区间定义保持不变，后续的边界处理都需依据这个不变的区间来操作。在使用二分法时，要关注循环或分支的进入条件，只有满足条件才会进入相应的循环或分支。

在`left <= right`的循环条件下，当计算出中间索引`middle`后，依据`nums[middle]`与目标值`target`的大小关系来调整边界：

- 若`nums[middle] > target`，由于`nums[middle]`肯定不等于`target`，且循环会处理`right == left`的情形，所以可以放心地将`right`更新为`middle - 1`。
- 若`nums[middle] < target`，鉴于`nums[left]`不可能等于`target`，并且循环会处理`nums[left]`和`nums[right]`相等的情况，所以能将`left`更新为`middle + 1`。

总体而言，关键在于判断下标为`middle`的元素是否会参与下一次判断。若不参与，且下次循环的处理会覆盖该元素相邻的元素，就能够安全地进行边界调整。





#### 也就是确保能够覆盖掉所有可能的条件？

可以这么理解。在二分法中维护 “循环不变量” 以及合理处理边界条件，本质上就是为了确保算法在执行过程中能够覆盖所有可能的情况。

通过每次循环对区间的合理收缩（根据中间元素与目标值的比较结果来调整左右边界），保证不会遗漏可能包含目标值的区域，从而在有限次循环后准确找到目标值（如果目标值存在于数组中）或者确定目标值不存在。



[27. 移除元素](https://leetcode.cn/problems/remove-element/)

```c++
class Solution {
    public:
    int removeElement(vector<int> &nums,int val){
        int slow=0;
        for(int fast=0;fast<nums.size();fast++){
            if(nums[fast]!=val){
                nums[slow++]=nums[fast];
            }
        }
        return slow;
    }
};
```

nums[fast]！=val的时候，下标fast对应的值赋给slow之后两个“指针”同时后移，当nums[fast]=val的时候，就slow不动，然后fast后移，在下次进入循环的时候，这个位置的值就会被slow路过的时候覆盖掉

[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

思路：创建一个数组用于存放排序后的元素。原数组上首尾双指针，由于首尾向中间都属于递减，所以可以比较首尾平方后的数值，然后较大的放在新数组尾部。

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        vector<int>result(n);
        int slow=0;
        int fast=n-1;

        for(int i=nums.size()-1;i>=0;i--){
            int Fast2=nums[fast]*nums[fast];
            int Slow2=nums[slow]*nums[slow];
            if(Fast2>=Slow2){//此情况为右边大，那就右边的放进数组，fast指针左移
                result[i]=Fast2;//放入
                fast--;
            }else{
                result[i]=Slow2;//放入
                slow++;
            }
        }
        return result;
    }
};
第一次：双指针的话，从首尾各出发一个指针。然后将较大的放在result数组末尾，那单次较小的怎么办，放哪里？下次循环得出的值还要跟这个较小的值比吗？--这是指针的思想，但是又多了一点将两者完全取出来的思维，好像那个小的必须得进行处理才行，这种思维是错误的。

第2次：有思路了，直接比，比完一个右指针左移，左指针右移，然后将指的值直接放进result就行，回到上个问题，较小的怎么办？谁几把管你，你又没动，呆在那里等下次比较就行。
```

#### 处理双指针时的错误思想：

双指针的话，从首尾各出发一个指针。然后将较大的放在result数组末尾，那单次较小的怎么办，放哪里？下次循环得出的值还要跟这个较小的值比吗？--这是指针的思想，**但是又多了一点将两者完全取出来的思维**，好像那个小的必须得进行处理才行，这种思维是错误的。   -------- 说说我这种错误思想出现的原因，以及如何避免

1. 对双指针算法理解不够彻底

这种思想是没有完全正确理解双指针，但是理解了一点，因为你知道了要两处出发。但没有意识到，可以单独控制指针的移动。每次可以对一个指针所指元素进行处理，然后指针进行处理，也可以同时处理两个指针以及指向的元素。操作的灵活性很强的。

2. 受排序算法影响

常规排序算法通常是对数组中每个元素进行逐一比较和交换位置，这种思想让你习惯了对每个元素进行直接处理。但是**双指针中重要的思想是指针的移动操作**，而不是对每次指向的元素进行详尽处理。

3. 缺乏整体规划和动态视角

思考过程过度关注单个元素的处理，没有从整体考虑数组的有序性和双指针的动态移动过程。双指针算法是一个动态的过程，每次比较和指针移动都会影响后续操作，要从全局把握而不是孤立的看待每个元素。

#### 如何避免

深入理解算法原理。区分不同算法思维方式，就比如这次的双指针和排序一混就忘记了双指针的特性了。 建立算法的全局观

## part02

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        //首先看思路吧，一个循环，用于向后遍历，fast走，每次找到大于target的数之后与之前的长度进行比较，然后
        //更新slow的位置，循环更新
        int min_length=0;
        int result=INT_MAX;//最后返回的是这个
        int left=0;
        int sum=0;
        for(int right=0;right<nums.size();right++){
            sum+=nums[right];
            while(sum>=target){//也就是说只有满足条件，就进入循环，循环中处理什么呢、想想如果是if的话处理什么
                //会求长度. 妈的，处理left指针啊，滑动窗口处理左窗口的时机是在满足sum>=target的时候开始移动左窗口，我之前的思路：满足sum>=target之后，左窗口右移。
                min_length=right-left+1;//求长度 
                //左边处理,怎么搞呢? 
                sum-=nums[left++];
               result= min_length<result?min_length:result;//这里处理result小于minlength，是的话result=resut，第一次的话 一个最大的数小于0？显然不成立，所以result被赋值为计算出来的minlength
            }
        }
        return result==INT_MAX?0:result;//result为初始值的话说明根本没进入while(sum>=target)也就是根本不存在满足条件的子数组
    }
};


```

### 滑动窗口

此概念需要明确几个问题：

1. 窗口内是什么？
2. 如何移动窗口的起始位置
3. 如何移动窗口的终止位置

本题中对应这三个问题的答案：

- 窗口内是该窗口中元素大于等于target的连续子数组‘
- 当sum>=target的时候就该进行移动了，注意在右窗口不变的时候满足sum>=target可能左窗口移动多次依然满足，所以满足该条件的时候应该进入循环判断，也就是while（sum>=target）。而不是在右窗口不移动的情况下单次的if（sum>=target）。

- 终止位置（右窗口）就是遍历该数组嘛。也就是外层循环中的索引



#### 思路错误：

我的思路刚开始是对左窗口的移动有点误解的：

我理解的是当右窗口移动到一个位置之后左窗口**每次都要从起始位置**循环右移。这里每次从起始位置就是有些错误的。

误解2：不是很懂result的赋值操作，result应该被min_length赋值。直接result=minlength不就行了，嗯。。要和上次的result进行大小比较的。

如果计算的minlength比上个结果小才赋值给result

所以有result= minlength<result?minlength:result；

误解3：不是很懂为啥result要设置为    int result=INT_MAX； 看2就知道了，第一次算出来的minlength不论如何都比这个INT_MAX小。



2025年5月7日：还是忘不掉群友问的一个问题：sum>=target，为什么等于target的时候还是要进入循环，我也懵逼了，现在想明白了，我们要求的又不是等于的情况，而是最小数组长度的情况，有很多相等的情况，你怎么判断这次就是长度最小的呢，所以要进入循环判断长度啦





-----

### 模拟法

螺旋矩阵

做法模拟，但是如何进行模拟很懵逼。代码使用什么结构进行处理方向的不同？怎么确定每个边填充的几次呢？比如n=4的时候与n=3的时候在圈层减1的时候每个边填充的元素都为1个，n=5的时候第二圈层是每次循环式填充两个。我草？所以每层填充几个是n/2啊？六层的时候，为3.

**嗯。。不对，思路不对，他的中心的那个是单独处理的，用loop代表处理几圈。5，4都是处理两圈，当其为5的时候有个心儿，心儿单独处理。也就是奇数的时候单独处理心儿**

#### 问题：

为什么使用while循环，该结构的特性是什么？什么时候循环结束呢？结束之后再进入循环条件是什么？

错误代码：

```c++
class Solution {
public://这里模拟的话，每圈分四次填充，填充的边界值记得整好，每次填充几个应该是n-1
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>result(n,vector<int>(n,0));//妈的为啥不初始化
        int loop=n/2;//就是需要处理几圈，n等于5的时候处理两圈，心儿单独处理，n=3的时候一圈，心儿单独处理
        int i=0,j=0;//进入下一圈的时候的得进行都加1处理,放在循环最后加吧
        int M_num=1;
        //四个墙
        int left=0;
        int right=n-1;
        int up=0;
        int down=n-1;
        while(loop--){//想想为什么要用while，以及什么时候会退出循环？

                //一圈的模拟处理.
                //左-》右
            for(;j<right;j++){
                result[i][j]=M_num;
                M_num++;
                right--;
            }
            //上-》下
            for(;i>down;i++){
                result[i][j]=M_num;
                M_num++;
                down--;
            }
            for(;j>left;j--){
                result[i][j]=M_num;
                M_num++;
                left++;
            }
            for(;i>up;i--){
                result[i][j]=M_num;
                M_num++;
                up++;
            }
            i++;
            j++;
        }
        if(n%2!=0){//有心的
            M_num++;
            result[i++][j++]=M_num;//
        }
        return result;
        
    }
};
```

#### 总结：

1. 重大错误，没有处理好不同对象的职责属性，比如i，j就是负责处理输出的result的中赋值用的，startX，startY就是为了处理矩阵用的，在之前的代码中，将i,j不仅处了轮旋矩阵还进行赋值操作，属于分工混乱了。**代码中创建的变量需要各司其职。**
2. 注意i j的巧妙使用，在单次循环中属于全局变量，累加起来之后还可以在下次for中使用，直接自减了。很好用的感觉。
3. 注意右->左 和 下->上 时候的终止条件，大于startX,startY 这个就属于矩阵用矩阵相关的变量了，他也会在一圈结束之后自加。 
4. 之前为了处理缩圈问题用了四个变量，在正确题解中只用了offset配合自加的startX与startY就完成了设置墙的操作。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>result(n,vector<int>(n,0));//创建一个矩阵用于返回结果
        int i,j;//o use set result[i][j];
        int loop=n/2;//to define how circle to process
        int startX=0;int startY=0;//to handle Matrix circle
        int offset=1;//处理一圈之后要缩圈
        int result_num=1;//填充的结果
        while(loop--){
            i=startX;
            j=startY;
            //因为要将处理后的矩阵的值赋值给result，所以将矩阵相关的startX给i
            for(;j<n-offset;j++){
                result[i][j]=result_num++;//赋值，自加
            }
            for(;i<n-offset;i++){
                result[i][j]=result_num++;
            }
            for(;j>startY;j--){//大于每次的起始位置，一圈结束之后startX会自加
            //并且注意，i,j在一次循环中属于全局变量，自加完之后，在单次while循环中下次使用依旧是自加之后的数值。
                result[i][j]=result_num++;
            }
            for(;i>startX;i--){//大于每次的起始位置，一圈结束之后startX会自加
                result[i][j]=result_num++;
            }
            startX++;
            startY++;
            offset++;
        }
        if(n%2!=0){
            result[n/2][n/2]=result_num;
        }
        return result;
    }
};
```

[LCR 146. 螺旋遍历二维数组](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

```c++
class Solution {
public:
    vector<int> spiralArray(vector<vector<int>>& array) {
        int m=array.size();
        int n=m*m;
        vector<int>result(n,0);//输出结果，先初始化
        //依旧得设置每层的起始下标
        int startX=0;
        int startY=0;
        //缩圈的时候要范围减小，该值需加加
        int offset=1;
        //
        int i,j;//用于处理矩阵中的数字
        int loop=m/2;//这个是循环几圈
        int count=0;
        while(loop--){
            i=startX;
            j=startY;

            for(;j<m-offset;j++){
                result[count++]=array[i][j];
            }
             for(;i<m-offset;i++){
                result[count++]=array[i][j];
            }
             for(;j>startY;j--){
                result[count++]=array[i][j];
            }
             for(;i>startX;i--){
                result[count++]=array[i][j];
            }

            startX++;
            startY++;
            offset++;
        }
        if(n%2!=0){
            result[count]=array[m-1][m-1];
        }
        return result;
    }

};
```

#### 错误之处：

1. `n` 的计算有误

在代码里，`n` 被赋值为 `m * m`，但 `m` 是二维数组 `array` 的行数，`n` 正确的含义应该是二维数组中元素的总数。所以，`n` 应当是 `array` 的行数乘以列数，而不是 `m * m`。

2. 处理矩阵元素个数为奇数时的情况有问题

当矩阵元素个数为奇数时，代码直接把 `array[m - 1][m - 1]` 赋值给 `result[count]`，这是不对的。正确的做法是根据实际的循环状况来确定这个单独元素的位置。

3. 打印矩阵的时候用例矩阵可能是`1*3或者2*3这种非正方形矩阵`，所以在从左到右处理的时候应该是小于n-offset n是一维数组的大小

```c++
class Solution {
public:
    vector<int> spiralArray(vector<vector<int>>& array) {
        if (array.empty()) return {};
        int m=array.size();
        int n=array[0].size();
        
        vector<int>result(m*n,0);//输出结果，先初始化
        //依旧得设置每层的起始下标
        int startX=0;
        int startY=0;
        //缩圈的时候要范围减小，该值需加加
        int offset=1;
        //
        int i,j;//用于处理矩阵中的数字
        int loop=min(m,n)/2;//这个是循环几圈
        int count=0;
        while(loop--){
            i=startX;
            j=startY;

            for(;j<n-offset;j++){
                result[count++]=array[i][j];
            }
             for(;i<m-offset;i++){//注意一个是n-offset，一个是m-offset因为这里有可能不是正方形矩阵，可能是1*3的可能是2*3的矩阵
                result[count++]=array[i][j];
            }
             for(;j>startY;j--){
                result[count++]=array[i][j];
            }
             for(;i>startX;i--){
                result[count++]=array[i][j];
            }

            startX++;
            startY++;
            offset++;
        }
        // if(n%2!=0){
        //     result[count]=array[m/2][m/2];
        // }
     // 处理剩余元素
        if (min(m, n) % 2 == 1) {
            if (m <= n) {
                for (int k = startY; k < n - startY; k++) {
                    result[count++] = array[startX][k];
                }
            } else {
                for (int k = startX; k < m - startX; k++) {
                    result[count++] = array[k][startY];
                }
            }
        }

        return result;
    }

};
```



----

https://kamacoder.com/problempage.php?pid=1070

### 前缀和

忘记了前缀和的概念了已经。

新创建一个数组，数组中每个元素存储的是该元素之前所有元素的和加上该元素的和。

求解区间内和的时候两种方法：

1. 传统暴力，将区间内值进行累加
2. 前缀和，根据计算好的数组，从区间尾对应的前缀和-（区间首下标-1）对应的前缀和



```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```



# 链表

## part01

[203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

有几个地方容易出错，并不是逻辑出错，而是指针方面可能会出错

1. 比如创建遍历指针的时候，创建`  ListNode *p=head->next;`还是创建`ListNode *p=head`? 

这里应该是创建后者，因为此时如果head为空的话，会引发空指针异常，因为对空指针 `head` 进行了 `->next` 操作。

2. 还有就是q的创建时机是什么时候呢？用的时候才创建，比如p->next->val==val的时候，才创建一个指针用于处理此情况。即用即创

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        while(head!=nullptr&&head->val==val){
            //删除头结点，将下一个节点设置为头节点
        ListNode *temp=head->next;
        head->next=nullptr;
        head=temp;//重装上head就行
        }
        //处理head之后的节点
        ListNode *p=head->next;
         ListNode *q=p->next;
        while(p!=nullptr&&q!=nullptr){
            if(p->next->val==val){//找到相同的就删掉
                p->next=q->next;
                delete q;
              //  q=p->next;
            }else{
            p=p->next;
            }

        }
        return head;
    }   
};
```

正确代码：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        while(head!=nullptr&&head->val==val){
            //删除头结点，将下一个节点设置为头节点
        ListNode *temp=head->next;
        head->next=nullptr;
        head=temp;//重装上head就行
        }

下面注释的这段代码可以替换上面的处理头结点的代码，原理是一样的，写法不一样而已
        // while(head!=nullptr&&head->val==val){
        //     ListNode*temp=head;
        //     head=head->next;
        //     delete temp;
        // }
        //处理head之后的节点
        ListNode *p=head;
        while(p!=nullptr&&p->next!=nullptr){
            if(p->next->val==val){
                //找到相同的才创建临时变量
                ListNode *q=p->next;
                p->next=q->next;
                delete q;
            }else{
                p=p->next;//没找到就p后移
            }
        }
        return head;
    }   
};
```

充分理解在创建指针的时候避免空指针异常的情况。尤其是创建一个指针指向另一个指针的next的时候。





[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

嗯，一个链表类实现增删改查，我节点类/结构体写在哪里呢？链表类构造的时候无参含参怎么构造呢？

在链表类中创建链表节点结构体

```c++
class MyLinkedList {
public:
//节点结构体创建
    struct LinkedNode {
        int val;
        LinkedNode  *next;
        LinkedNode (int val):val(val),next(nullptr){};
    };
    MyLinkedList() {
        //链表类的话无参构造需要默认一个dummyhead其长度为空
        _size=0;
        _dummyhead=new LinkedNode (0);//指针参数，默认的话给你创建个新位置你指着吧
    }   
    
    int get(int index) {//头结点下标为0
        if(index<0||index>_size-1){
            return -1;
        }
        LinkedNode *cur=_dummyhead->next;
        while(index){
            cur=cur->next;
            index--;
        }//这个while循环的话，如果Index为0直接返回dummyhead->next 如果为其他的也可以正常返回，如果非正常输入的话，则直接返回-1了
        return cur->val;
    }
    //addAtHead应该是没问题的直接在虚拟头结点后面加了
    void addAtHead(int val) {
        LinkedNode  *Node=new LinkedNode (val);
        Node->next=_dummyhead->next;
        _dummyhead->next=Node;
        _size++;//节点加上了，链表长度加加
    }
    //加到尾节点应该直接将遍历的指针放到虚拟头结点比较好吧
    void addAtTail(int val) {
       // LinkedNode  *cur=_dummyhead->next;
        // while(cur->next!=nullptr){
        //     cur=cur->next;
        // }
        // LinkedNode *newNode=new LinkedNode (val);
        // cur->next=newNode;
        // _size++;
        LinkedNode  *cur=_dummyhead;
        while(cur->next!=nullptr){
            cur=cur->next;
        }
        LinkedNode *newNode=new LinkedNode (val);
        cur->next=newNode;
        _size++;
    }

    void addAtIndex(int index, int val) {//通过下标加也是，得将指针从头结点开始循环
        // LinkedNode *p=_dummyhead->next;
        // if(index>_size-1||index<0)return ;
        // if(index==_size-1){
        //     addAtTail(val);//如果等于长度，则加到末尾
        // }else{//小于总长度进行添加操作
        // index-=1;//减1，能够在p后面直接插一个节点
        //     while(index){
        //         p=p->next;
        //         index--;
        //     }
        //     LinkedNode  *newNode=new LinkedNode (val);
        //     newNode->next=p->next;
        //     p->next=newNode;
        //     _size++;
        // }
        //插入一般还是从虚拟头开始的。在第几个下标之前插入就意味着插入的这个下表为Index
        LinkedNode *cur=_dummyhead;
        if(index>_size)return;
        if(index<0)index=0;
        while(index--){
            cur=cur->next;
        }  
        LinkedNode*newNode=new LinkedNode(val);
        newNode->next=cur->next;
        cur->next=newNode;
        _size++;
 
    }
    
    void deleteAtIndex(int index) {
        LinkedNode *p=_dummyhead;
        if(index>_size-1||index<0)return ;
        while(index--){
            p=p->next;
        }
        LinkedNode *q=p->next;
        p->next=q->next;
        delete q;
        q=nullptr;
        _size--;
    }
private:
    int _size;
    LinkedNode  *_dummyhead;
     
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

添加和删除的时候遍历指针最好从虚拟头结点开始，这样**处理头结点增删相关的操作时**会方便很多

在第一次处理的时候我是将循环指针设为LinkedNode *p=_dummyhead->next;。这样还要单独处理插入头结点的情况，也就是说设计虚拟头结点你却其二不用了，暴殄天物。





[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

已经忘的一干二净了，我甚至想用一个dummyhead节点作为虚拟头节点，然后后面的逐个处理加在这个后面，但是题解根本没有使用虚拟头节点，而是使用pre指针和cur双指针。

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //处理链表的时候要优先处理空链表的情况，因为和指针相关，所以就要注意空指针的情况。
        if(head==nullptr||head->next==nullptr)return nullptr;
        ListNode* _dummyHead=new ListNode(0);
        _dummyHead->next=head;
        ListNode*cur=_dummyHead;
        while(cur->next!=nullptr){

        }
};
```

双指针正解：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //首先想想翻转链表需要什么东西进行翻转，指针应该怎么动，需要几个指针
        //想想一些特殊条件，头节点为空的情况。
        //if(head==nullptr&&head->next==nullptr)return head;
        ListNode *cur=head;//头节点上放个指针用于后移不犯毛病的
        ListNode *pre=nullptr;
        while(cur!=nullptr){//cur!=nullptr的时候继续循环，cur==nullptr的时候退出循环。为什么不是cur->next==nullptr的时候退出循环，因为cur->next==nullptr的时候还是得转换的呀，此时若是退出，则最后两个节点之间没有进行翻转
            ListNode*temp=cur->next;
            cur->next=pre;
            pre=cur;//pre先后移、、
            cur=temp;//cur再后移
        }
        return pre;
        }
};
```

二〇二五年四月三十日 这个**temp节点**没整明白其作用呀，他的作用是为了cur能够后移，而不是为了能够让pre连接到temp.今天又做了一遍总想让pre->next=temp.太极吧抽象了。

1.temp是为了给那个指针用的。。给cur后移使用的，因为的那个cur的呢next指针变的时候就没办法找到原本的后续节点了

2还有为什么先移动pre,后移动cur？因为如果先移动cur的话，cur变化了，pre就没办法移动了。

3为什么while循环的时候条件是cur！=nullptr。且返回的是pre？

-  cur!=nullptr的时候继续循环，cur==nullptr的时候退出循环。为什么不是cur->next==nullptr的时候退出循环，因为cur->next==nullptr的时候还是得转换的呀，此时若是退出，则最后两个节点之间没有进行翻转

4.初始化指针的时候怎么初始化，你是怎么想到的？



递归：

```c++
    /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode() : val(0), next(nullptr) {}
    *     ListNode(int x) : val(x), next(nullptr) {}
    *     ListNode(int x, ListNode *next) : val(x), next(next) {}
    * };
    */
    class Solution {
    public:
        ListNode *reverse(ListNode* pre,ListNode* cur){
            if(cur==nullptr)return pre;
            ListNode*temp=cur->next;
            cur->next=pre;
            //单层循环结束之后进入下一层循环的做法：
          return  reverse(cur,temp);
        }
        ListNode* reverseList(ListNode* head) {
          return reverse(nullptr,head);
            }
    };
```

复习递归三部曲：

- 确定参数和返回值
- 确定终止条件
- 确定单层递归条件







## part02



















# 哈希表

## part01





整理下哈希增删改查：

key-value

**创建/构造**哈希map: `unordered_map<int,int>mapInt;`

**添加**map数据，三种添加方式：

`mapInt[1]=3;`

`mapInt.insert(pair<int,int>(1,3));`

`mapInt.insert(unordered_map<int,int>::value_type(1,3));`

**查找find()**:iterator find (const Key& k);  查找键`k`，若找到，返回指向该元素的迭代器；若未找到，返回`end()`迭代器。

find（）函数返回	的是一个迭代器指向的是键值为key的元素，find的参数是什么？如果没找到就返回指向map尾部的迭代器,也就是返回指向end()的迭代器。

**删除：**

erase();删除函数，有三种删除方法，按键删除、按迭代器删除以及范围删除



> 对stl的一些用法函数无非就是一些增删改查的使用，然后就是结合迭代器使用，几种STL的关键字基本都是通用的。

---

#### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

思路：

两数之和，使用哈希表怎么解？

一个整数数组，一个target目标值，从数组中找出两个数加起来和为target的两个元素下标。

遍历整个数组，遍历到一个插入到哈希表中一个。遍历到一个数的时候target-该数，能够在哈希表中找到，

但是怎么知道这个数对应的下标呢？使用`->first`访问吗？

但是这题中是将元素作为key,数组中的下标存储的时候作为Value，为什么呢？

这应该是跟哈希表的查找方式有关吧

map在此题中的作用：**存放已经遍历过的元素**，然后在后续遍历中查找target-num[i]是否能够在hash中找到，找到就返回存的value（也就是对应数组的下标），和此时遍历到的下标。



```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>toUse;//创建一个哈希表，助我使用
        vector<int>result(2,0);
        for(int i=0;i<nums.size();i++){
         //遍历，边遍历变插入？
         if(toUse.find(target-nums[i])==toUse.end()){
            toUse.insert(pair<int,int>(nums[i],i));
         }else{
            //如果找到了就返回两个下标
                result[0]=i;
                result[1]=toUse[target-nums[i]];
            return result;
         }   
        }
        return result;
    }
};   
```

可以变化的地方，find返回值为iterator迭代器，所以可以在 ==toUse.end（）的时候使用变量接收find的返回值

`auto it=toUse.find(target-nums[i]);`//嗯只是为了熟悉下auto和find的返回值的用法、

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>TempHash;
        for(int i=0;i<nums.size();i++){
            auto it=TempHash.find(target-nums[i]);
            if(it==TempHash.end()){
                //没找到就放在hash中啊
              TempHash.insert(pair<int,int>(nums[i],i));  
            }else{
               // return {i,TempHash[target-nums[i]]}; 可以用，但是我已经有find到的元素的迭代器了，直接用下面的方法就行
                return {i,it->second};
            }
        }
        return {};
    }
};   
```

#### [求两个数组交集 ](https://leetcode.cn/problems/intersection-of-two-arrays/)

这个题怎么漏过去了

两个关键点：

1. set和vector之间的转换没用过。
2. 解题使用的find,求解思路：一个数组中元素能够在hash中找到，就将这个元素添加到result（hash)中.

赎金信那种题目是找到key的话，直接对该元素的value进行修改。最后可以根据题目不同再做不同的操作。

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int>result;
        unordered_set<int>VtoSet(nums1.begin(),nums1.end());
        for(int i:nums2){
            if(VtoSet.find(i)!=VtoSet.end()){
                //找到就加进去
                result.insert(i);
            }
        }
        return vector<int>(result.begin(),result.end());
    }
};
```

**question：**

### unordered_set

I have a question set**能用下标访问吗？**

不能，unordered_set也不可以。

1. 因为set是使用的红黑树存储，并不是连续存储空间，所以不能通过偏移量（即下标）直接访问。
2. 缺乏随机访问迭代器，std::set只提供双向迭代器，只能向前或者向后逐个遍历元素，无法直接跳到指定位置。

unordered_set同样不支持下标访问元素。

1. std::unordered_set特性 ： 为C++标准库中无序关联容器，利用哈希表存储元素。其存储的元素是无序且唯一的。
2. 其不支持下标访问的原因：
   1. 缺乏顺序保证：unordered_set中元素没有固定顺序，其元素位置由哈希函数和哈希表的实现决定。
   2. 内存分配不连续，下标访问依赖元素在内存中连续存储，通过偏移量快速定位元素，而unordered_set不满足这一条件
   3. 迭代器类型：没有随机迭代器访问，只有前向迭代器，只能逐个向前遍历访问。或者使用find（）查找函数

而map能用下标访问，为什么？

主要有以下几个原因：设计目的，数据机构，使用场景这几个原因相关

##### 设计目的

map是用于存储键值对的容器，其**核心作用是建立键与值之间的映射关系**。通过键来访问和修改值是常见的操作需求，重载[]可以让开发者以简洁直观的方式完成这种操作，就像数组一样，极大提升了代码的可读性和易用性。

而set只存储唯一的元素，其**主要目的是对元素去重和排序**。在set中，元素本身就是键，不存在键值对这一概念，因此也就没有使用[]访问值的需求。

> 哈哈，map重载[]是为了访问key对应的value,set没有value当然不用访问了,重载[]没有意义，不要将其访问set的键跟数组的下标混为一谈。因为数组下标的索引和值也可以看做key-value 但是set的话，只有键，看他的名字也就知道，其只是个集合。

##### 数据结构

map中重载的运算符[],通常使用[]访问元素时，先会查找键是否存在，若存在则返回对应值的引用，若不存在，则插入新的键值对。

而set，元素位置由元素本身的值决定，不适合用下标来访问。set中是按照特定顺序存储，unordered_set中则是根据hash函数和哈希表的实现存储的，谁知道位置会在哪里呢。

##### 使用场景

map:在需要根据某个键快速查找插入或者修改对应值的场景，map非常有用。例如存储学生键可以是学生的学号了，值可以是学生的分数，使用[]可以方便地根据学号访问和修改学生的分数

```c++
#include <iostream>
#include <map>
int main(){
    	std::map<int,int>scores;
    	scores[1001]=90;、、插入学号为1001的学生分数90分
        int score = scores[1001]; // 根据学号访问成绩
    	std::cout << "The score of student 1001 is: " << score << std::endl;
   		return 0;
    
}
```

set:常用于需要对元素进行去重和排序额场景。如统计一篇文章中出现的不同单词有哪些，只需要遍历插入到set中的元素输出。如果需要验证单词是否出现在其中过也可以进行find进行验证。



##### unordered_set的find函数实现方式：

奶奶的我就知道你不一样。find函数是unordered_set的成员函数，其实现方式是

1. 1.计算哈希值，当使用find函数并传入一个待查找的值的时候，会使用哈希表所使用的hash函数对该值进行计算，算得一个hash值
2. 定位到桶：这个hash值会被映射到桶数组的一个特定索引位置
3. 遍历桶中所有元素，通常会使用operator==将其与待查找的值进行比较
4. 返回结果，如果遍历过程找到了与待查找值相等的元素，则返回指向该元素的迭代器，如果遍历完整个桶都没有找到匹配元素，则返回end()迭代器，表示未找到该元素。

## part02

#### 四数相加



怎么解题？先两个数组进行相加，统计两个数组中出现的所有值以及这些值出现的次数。使用map存储，然后后两个数组从其中进行选择map中需要的数据，然后进行加加

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int>result;
        for(int a:nums1){
            for(int b:nums2){
               //可以用数组的形式代表哈希表
               result[a+b]++;
            }
        }
        int count=0;
        for(int c:nums3){
            for(int d:nums4){
                if(result.find(-(c+d))!=result.end()){
                    //代表能在result中找到对应的值，正因为需要和之前的内容相反，才需要取反之后再在hash中找对应键
                    count+=result[-(c+d)];//不能直接加加，因为有可能相同的结果出现好几次，所以应该是加result中的值
                }
            }
        }
        return count;
    }
};
```

- 若 `-(c + d)` 这个键存在，那么 `result[-(c + d)]` 就代表这个键对应的值，也就是 `nums1` 和 `nums2` 中元素相加结果为 `-(c + d)` 的组合的数量。把这个数量累加到 `count` 中，就可以得到满足 `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0` 的元组数量。

#### 快乐数

拆分为两个目标，目标1：拆分函数，每个多位数拆成单独的的数字。然后返回各个数字平方之后的和的结果。

目标2:将数据存入哈希表，循环判断其中有没有等于1的，有则return true。



```c#
class Solution {
public:
    int getNum(int n){
        int sum=0;
        while(n){
            sum+=(n%10)*(n%10);
            n=n/10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int>result;
        while(1){
            int s=getNum(n);
            if(result.find(s)==result.end()){
                result.insert(s);
            }else if(s==1){
                return true;
            }else{
                //转回去循环调用getNum；怎么转回去？
                n=s;
            }
        }
    }
};
```

这里就陷入误区了。没明白循环中的处理信息，以及什么情况下处理什么。

#### 问题：

1. 不清晰什么时候返回false。

> ` if(result.find(s)!=result.end())`//哈希表中找到了和这次计算相同的数，意味着计算陷入循环了，之后的计算会不断重复这个循环，且这个循环不包含1因此不是快乐数

2. 刨除判断条件，也就意味着该循环一直处理的是：

```c++
while(1){
	s=getNum(n);
	n=s;
}
```

也就意味着一直循环，然后添加上条件，条件满足的时候才是退出循环的时机。

完整代码：

```c++
class Solution {
public:
    int getNum(int n){
        int sum=0;
        while(n){
            sum+=(n%10)*(n%10);
            n=n/10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int>result;
        while(1){
            int s=getNum(n);
                if(result.find(s)!=result.end()){//哈希表中找到了和这次计算相同的数，意味着计算陷入循环了，之后的计算会不断重复这个循环，且这个循环不包含1因此不是快乐数
                    return false;
                }else if(s==1){
                    return true;    
                }else{
                    result.insert(s);
                }   
            n=s;
        }
    }
};
```



#### 赎金信

简简单单赎金信，就是查hash表中有没有相关的key以及具体的value进行变化

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map<int,int>library;
        for(int i=0;i<magazine.size();i++){
            library[magazine[i]-'a']++;//循环各个字母进行hash表中元素value修改
        }
        for(int j=0;j<ransomNote.size();j++){
            //直接从刚有的hash表中进行筛查，刚才的属于库中元素及其个数，这里直接减就行
            library[ransomNote[j]-'a']--;
        }
        for(auto i:library){
            if(i.second<0){
                return false;
            }
        }
        return true;
    }
};
```

吊毛别忘了，除了set哈希，map哈希,数组也可以做哈希表。

而且知道具体值最多只有26个，数组的话运算速度更快。

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
       int library[26]={0};
        for(int i=0;i<magazine.size();i++){
            library[magazine[i]-'a']++;//循环各个字母进行hash表中元素value修改
        }
        for(int j=0;j<ransomNote.size();j++){
            //直接从刚有的hash表中进行筛查，刚才的属于库中元素及其个数，这里直接减就行
            library[ransomNote[j]-'a']--;
        }
        for(int i=0;i<26;i++){
            if(library[i]<0){
                return false;
            }
        }
        return true;
    }
};
```

#### 三数之和 

[15. 三数之和](https://leetcode.cn/problems/3sum/) 梦破碎的地方

明确题目，一个数组中三个数，三个数相加等于0，找出所有符合条件且不重复的三元组返回。

主要使用双指针了，双指针中也是要去重的，去重的时候是跟i所在的值前面一个相比还是后面一个相比还是不同的。这里要做好区分。还有就是一个continue 继续下一轮循环，continue关键字没怎么用过。

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 首先将数组排序
        vector<vector<int>> result;
        int n = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 开始去重，当i大于0的之后的直接不用考虑了
            if (nums[i] > 0)
                return;
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                if (nums[i] == nums[i - 1])
                    continue;
                else if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                }else{
                    //这个里面就是先收集结果，然后再去重操作
                    result.push_back(nums[i],nums[left],nums[right]);
                    //这里真不会这几个数放进去啊。
                    while(nums[left]==nums[left-1])left++;
                    while(nums[right]==nums[roght+1])right++;
        
                }
                right--;
                left++;
                //判断条件结束之后进行同时收缩
            }
        }
        return result;
    }
};
```



这里有几个问题：

1. 在push_back二维数组的时候有点蒙蔽。
2. 什么时候进行同时收缩的逻辑有点不清晰。
3. 去重a的位置逻辑有问题，不应该放在while(right<left)中，应该是在for循环中
4. b,c 去重逻辑搞清楚一点

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        // 首先将数组排序
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 开始去重，当i大于0的之后的直接不用考虑了
            if (nums[i] > 0) {
                return result;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            while (right > left) {

                if (nums[i] + nums[left] + nums[right] > 0) {
                    right--;
                } else if (nums[i] + nums[left] + nums[right] < 0) {
                    left++;
                } else {
                    // 这个里面就是先收集结果，然后再去重操作
                    result.push_back(
                        vector<int>{nums[i], nums[left], nums[right]});
                    // 这里真不会这几个数放进去啊。
                    while (right > left&&nums[left] == nums[left + 1]) {//这里去重的位置之前搞错了应该是left+1.妈的，这里居然会搞错，已经更正
                        left++;
                    }
                    while (right > left&&nums[right] == nums[right - 1]) {
                        right--;
                    }

                    right--;
                    left++;
                    // 判断条件结束之后进行同时收缩
                }
            }
        }
        return result;
    }
};
```



#### 四数之和



三数之和是通过双指针的解法将O3的时间复杂度降至O2，四数之和是将O4的时间复杂度降至O3，需要注意的是三数之和的剪枝操作是nums[i]>target的时候就可以忽略（因为数组有序且，target为0.）但是四数之和不行，因为四数之和的target不确定，当仍旧使用nums[i]>target的时候会造成结果丢失 比如 -5 -4 0 0 target=-9 此时-5>-9 如果仍用之前的剪枝判断就会导致此结果集丢失。

所以优化方法是 if(nums[i]>target&&(nums[k]>=0||target>=0))

```C++

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        vector<vector<int>>result;
        for(int k=0;k<nums.size();k++){
            if(nums[k]>target&&(nums[k]>=0||target>=0)){
                break;
            }//剪枝
            if(nums[k]==nums[k-1]){continue;};//去重

            for(int i=k+1;i<nums.size();i++){
                //二级剪枝
                if(nums[k]+nums[i]>0&&nums[i]>=0){
                    break; //nums[i]>0的时候，后面都大于0,也就全剪掉了
                }
                if(nums[i]==nums[i-1]){
                    break;//去重
                }
                int left=i+1;
                int right=nums.size()-1;
                while(left>right){
                    //双指针进行移动处理，首先处理收缩规则：
                    if((long)nums[k]+nums[i]+nums[left]+nums[right]>target){
                        right--;
                    }
                    else if((long)nums[k]+nums[i]+nums[left]+nums[right]<target){
                        left++;
                    }else{
                        result.push_back(vector<int>{nums[k],nums[i],nums[left],nums[right]});//用花括号回收整个一个集合
                        //收获完成之后去重，收缩
                        while(nums[left]==nums[left+1])left++;
                        while(nums[right]==nums[right-1])right--;

                        right--;
                        left++;
                    }
                }

            }

        }
        return result;
    }
};
```

有报错，但是没有显示哪一行，可能是有些限制条件没有加上

全部解决，都在注释---符号之后的有误之处：

```c++

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        for (int k = 0; k < nums.size(); k++) {
            if (nums[k] > target && (nums[k] >= 0||target>=0) ) {
                break;
            } // 剪枝
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }; // 去重   --why强调k>0;

            for (int i = k + 1; i < nums.size(); i++) {
                // 二级剪枝
                if (nums[k] + nums[i] > target &&
                    nums[i] >= 0) { //---这里搞错了应该是nums[k]+nums[i]>target
                    break; // nums[i]>0的时候，后面都大于0,也就全剪掉了
                }
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue; // 去重  --为什么要加上i>k+1;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {//妈的，左右写错了，撒比
                    // 双指针进行移动处理，首先处理收缩规则：
                    if ((long)nums[k] + nums[i] + nums[left] + nums[right] >
                        target) {
                        right--;
                    } else if ((long)nums[k] + nums[i] + nums[left] +
                                   nums[right] <
                               target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{
                            nums[k], nums[i], nums[left],
                            nums[right]}); // 用花括号回收整个一个集合
                        // 收获完成之后去重，收缩
                        while (right > left && nums[left] == nums[left + 1])
                            left++;
                        while (right > left && nums[right] == nums[right - 1])
                            right--;

                        right--;
                        left++;
                    }
                }
            }
        }
        return result;
    }
};
```





> 看起来很恐怖一大段的代码，其实写起来也没什么。。很多时候我们都是被自己的恐惧吓到的。



## hash之总结篇

> 哈希表用于快速判断一个元素是否存在集合中

其实不止一个，可以用循环判断是否这些数存在集合中

对于哈希表，要知道**哈希函数**和**哈希碰撞**在哈希表中的作用。

哈希函数是将传入的key映射在符号表的索引上。然后映射的时候就有可能出现多个key映射到同一个索引上的情景，这就出现了哈希碰撞。处理方法通常是拉链法和线性探测法。

几种哈希结构：

- 数组
- set(集合)  C++STL提供了set,multiset,unordered_set
- map(映射) C++STL提供同上也有三个

**哈希经典题目**

- 数组作为hash表的时候，比如数组大小受限时，比如题目中包含小写字母。小写字母意味着只有26种情况，使用数组hash最快，空间时间消耗最短
- set作为hash表的时候[求两个数组交集 (opens new window)](https://leetcode.cn/problems/intersection-of-two-arrays/)的时候使用

此题思路是判断能否在hash表中找到该元素，可以则将其insert进新的hash中。最后返回这个hash转换成vector的结果





# 字符串

## part01

#### [反转字符串](https://leetcode.cn/problems/reverse-string/)

```c++
class Solution{
    public:
    void reverseString(vector<char>&s){
        // int i=0;
        // int j=s.size()-1;
        // while(i<j){
        //     swap(s[i],s[j]);
        // }超时了
        for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
            swap(s[i],s[j]);
        }
    }
};
```

emmmm....while的超时是因为没有进行i,j收缩呀

```c++
class Solution{
    public:
    void reverseString(vector<char>&s){
        int i=0;
        int j=s.size()-1;
        while(i<j){
            swap(s[i],s[j]);
            i++;
            j--;
        }
    }
};
```





#### [反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)

```c++
以下是错的题解：
class Solution { 
public: 
    string reverseStr(string s, int k) { 
     //首先是要遍历字符串的 
     for(int fast=0;fast<s.size();fast+=k){ 
        int slow=0; 
        if(fast%k==0){//满足等与2k的条件时要干什么 
            //翻转前k个 
            swap(s[slow],s[slow+k]); 
            slow+=2*k;//slow前提至下一个需要反转的位置。 
        }else{ 
            swap(s[slow],s[s.size()-slow]); 
        } 
        } 
        return s;   
    } 
};
```



##### 代码中的问题
主要错误：

1. 变量初始化问题 ： slow 变量在每次循环中都被重置为0，这会导致每次都从字符串开头开始操作。
2. 反转逻辑错误 ：使用单个 swap 无法完成整个子串的反转，需要使用双指针或库函数来反转k个字符。
3. 条件判断错误 ： fast%k==0 不是判断是否满足2k的条件，应该使用 fast%(2*k)==0 。
4. 索引计算错误 ： slow+k 可能会超出字符串范围，需要检查边界条件。
5. 循环步进错误 ： fast+=k 会导致每次只前进k个字符，而题目要求每2k个字符为一组。



正确代码：

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
     //首先是要遍历字符串的
     int n=s.size();
     for(int i=0;i<n;i+=2*k){
        int slow=i;
        int fast=min(i+k-1,n-1);//使用min是为了处理最后末尾的部分
        while(slow<fast){
            swap(s[slow],s[fast]);
            slow++;
            fast--;
        }
        }
        return s;   
    }
};
```



**字符串与数组的关系：**

字符串是若干字符组成的有序序列，也可以理解为一个字符数组。结尾符号是`\0`,但是判断条件不能是以下这样：

```c++
int main(){

    char a[5]={'y','u','y','u','e'};
    for(int i=0;i!='\0';i++){
        cout<<a[i]<<" ";
    }
    cout<<endl;
    return 0;
}
```

这在一开始就是不成立的，因为i=0为int类型，‘\0’属于字符类型，所以不会进入循环，一开始就不满足进入循环的条件：），所以不会打印任何东西



#### 反转字符串中的单词

[(https://leetcode.cn/problems/reverse-words-in-a-string/)

三个点 1。处理函数。 2.自定义翻转函数。 3.主函数处理逻辑：先翻转整个处理过后的字符串，再翻转单个单词

##### 点1 处理多余空格

给一个字符串，要反转其中的单词，怎么翻转，首先要对字符串进行处理去除多余空格，怎么去除呢？比如下面的一个字符串：

`"  Hello   liyinming Amanda  xiamen  "`.其中字符串首尾以及字符串中间都是有多余空格的。这个怎么处理呢？

想想之前做过的题去除数组中target，一样的道理这里target就是空格，只需要判断之后从前到后进行覆盖即可。

创建处理函数removeExtraSpaces 函数

```c++
void removeExtraSpace(string &s){
	int slow=0;
	for(int i=0;i<s.size();i++){
		if(s[i]！=' '){
			if(slow!=0) s[slow++]=" ";//加空格操作，slow!=0意味着不是第一个元素的时候。
			while(i<s.size()&&s[i]!=' '){
                s[slow++]=s[i++];
            }
		}
	}
    s.resize(slow);
}
```

如果不理解这段代码，直接在编辑器中打断点 逐行执行就能清晰的看到过程了

##### 点2 翻转函数

```c++
reverse(string &s,int start ,int end){
    for(int i=start,j=end;i<j;i++,j--){//注意使用形参，因为有两次翻转呢，一次整体，一次单个单词翻转
        swap(s[i],s[j]);
    }
}
```

整体函数：

```c++
class Solution {
public:
    void reverse(string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    };
    string removeExtraSpace(string& s) { // 去除空格
        int slow = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] != ' ') {
                if (slow != 0)
                    s[slow++] =' ';// 这是啥意思呢，就是i跨过了好多个空格，然后遇到一个新单词了，只需要slow++自己创建一个新空格，其他处理情况就是跟着i进行覆盖
                while (s[i] != ' ' && i < s.size()) {
                    // 覆盖
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow);
        return s;
    };
    string reverseWords(string s) {
        removeExtraSpace(s);
        reverse(s, 0, s.size() - 1);
        // 开始进入逐个单词处理
        int start = 0;
        for (int i = 0; i <= s.size(); i++) {//i要小于等于s.size()才能翻转到最后一个单词，并且这样处理也不用在处理最后一个单词的时候进行特殊处理，，因为前面的都是遇到空格的时候翻转空格之前的单词也就是start到i-1位置的字符。
            if (s[i] == ' ' || i == s.size()) {
                reverse(s, start, i - 1);
                start = i + 1;
            }
        }
        return s;
    }
};
```

注意主函数中单个单词翻转时候的逻辑，for循环的进入条件是`i<=s.size()`.注意可以等于。

因为条件是遇到是s[i]==' '的时候才将i之前的单词进行翻转，所以在处理末尾的时候应该是i要指向最后一个元素的后面时也就是i==s.size()的时候，此时翻转仍可用  reverse(s, start, i - 1);进行处理，不用对最后部分进行单独处理了。



-----

复习链表相关知识：

删除链表元素。三种方法复习：无虚拟头结点，使用虚拟头结点，使用递归。

无虚拟头结点的时候要删除元素记得对头结点进行单独处理（因为需要不断调整确定该链表的头结点），之后对后续节点进行判断处理，使不使用dummy都要注意指针后移操作的顺序，p先动，q后动。

使用递归的话。明确递归的三部曲：明确参数和返回值，明确单次循环终止条件，明确单词循环逻辑。

递归实现：

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 如果使用递归
        // 如果为空
        if (head == nullptr) {
            return nullptr;
        }
        // 如果头结点符合删除条件
        if (head->val == val) {
            ListNode* newHead = removeElements(head->next, val);
            delete head;
            return newHead;
        } else {
          
            head->next = removeElements(head->next, val);
            return head;
        }
        // 后续前进？
    }
};
```

说实话不理解。。   `head->next = removeElements(head->next, val);`是一直后移下去吗





对于递归的使用，即使明确三步法但是依旧不是很理解为啥用着三步，然后我需要进行深度解析这三步的联系

首先就是为什么使用递归？

使用递归函数是因为我想用**同样的逻辑解决一个更小规模的子问题。**这里子问题是什么意思，结合上面链表来说，这个“子问题”的定义并不是父子关系，而是从整体来看的一个相似的小问题。

##### 三步之1输入输出

既然使用了递归函数解决问题，我们就要明确这个**函数需要什么样的输入与返回值**。也就分别对应的是输入：递的过程。返回值：终止“递”的操作时会返回什么结果。（亦或者不用返回任何结果）

对于上面删除链表元素的例子，可以获悉，递归函数的定义是：删除head为头结点的链表中所有值为val的节点，返回处理后的新链表的头结点

所以每次调用该函数的时候`removeElements(head->next, val)`，对于子链表来说都有一个新的头节点head,和一个要处理的值val.

输入：子链表head,val

返回：处理过后的头节点

##### 三步之2终止条件

递归啊，就是相当于压栈操作，如果没有终止条件那不就是无限循环吗？如果没有终止条件将会导致栈溢出或无限递归

在上述例子中的终止条件就是子问题的head为空时，也就意味着整个链表到结尾了，可以终止了。

##### 三步之3单次递归逻辑

这个就是处理递的逻辑和归的逻辑的关系了。比较难处理，明确**如何递，如何归**。比如上述问题中，通过分支处理是否等于val进行处理。递的操作都是`removeElements(head->next, val);`但是归的时候分情况了。【归的过程就是逐渐靠近首次递归入口】

```c++
        // 如果头结点符合删除条件
        if (head->val == val) {
            ListNode* newHead = removeElements(head->next, val);
            delete head;
            return newHead;
        } else {
          
            head->next = removeElements(head->next, val);
            return head;
        }
```

情况为  ` if (head->val == val) `可以看到，当头结点符合条件时返回的是newHead。也就是**在处理该节点时**根据归的结果进行返回，如果接收的归的结果是空，也就意味着返回的newHead为空，如果返回的结果非空，也就意味着该节点在归的过程将非空节点逐渐靠近首次递归入口。

而情况为` if (head->val != val) `时使用head->next进行接收“归”来的数据，也就是要联系上"归"上来的节点用于建立链表关系，这样所有同性质的节点都能够通过next进行联系形成处理之后的完整链表.

### [链表part02](part02)

两两交换链表中的节点

直接递归

```c++
part02class Solution {
public:
    ListNode* reverse(ListNode *node){
        if(node==nullptr||node->next==nullptr)return node;
        ListNode*p=node;
        ListNode*q=node->next;
        ListNode*temp=q->next;
        q->next=p;
        p->next=reverse(temp);//递 归 处理后续两个节点
        return q;
    }
    ListNode* swapPairs(ListNode* head) {
            return reverse(head);
    }
};
```



