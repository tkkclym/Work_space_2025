# Client side tool development side

观察者模式

指针和引用， 指针引用所占的大小

左值和右值， i++和 ++i 分别是左值还是右值

移动语义

std::move 实现

析构函数声明为虚函数的作用

介绍多态

多继承两个父类有相同的虚函数， 子类重写的是哪个

同名的函数，一个接受指针一个接受引用， 是不是重载

野指针

static 修饰不同的变量

反射的了解

 STL 容器

resize 和 reserve 区别

vector 扩容

unordered_set

哈希冲突

使用开放定址法如何删除元素

快排思路

tcp， udp

进程和线程

线程同步

条件变量的实现原理

c++ 的内存分区

物理内存和虚拟内存
链接：https://www.nowcoder.com/feed/main/detail/8e674156d871449f9e4242655d010d29?sourceSSR=search
来源：牛客网





#### 同名的函数，一个接受指针一个接受引用， 是不是重载



答案：是重载。C++中一个同名函数一个接受指针参数，一个接受引用参数，属于合法的函数重载。

因为指针和函数在**类型系统**中被认为是不同的参数类型。

1. 类型系统差异：

- 指针int* 和引用 int& 是两种不同的类型
- 编译器会将void Func(int*)和void Func(int&)视为参数列表不同的函数

2. 调用时的明确性：

- 调用指针版本需要显式传递地址，如Func(&x);
- 调用给你引用版本直接传递对象，如Func(x);
- 编译器会根据实参类型自动选择匹配版本

#### 哈希冲突



#### 开放定址法如何删除元素？

开放定址法是处理哈希表冲突的方法，当发生哈希冲突时，通过一定的探测方法在哈希表中寻找下一个可用的位置。



**使用开放定址法在哈希表中删除元素，不能简单地将该位置置为空 ，为什么？**

答：因为可能会破坏后续查找其他元素的路径，在后续查找其他元素的时候，可能会因为遇到空位置提前终止查找，导致找不到原本存在的元素。通常采用标记删除的方法，使用一个特殊标记来表示该位置元素已删除，而不是真正地清空该位置。这样在后续删除查找和插入操作中遇到这个标记会继续探测就好像该位置没有元素一样。

